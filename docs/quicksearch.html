<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"widget_client.js.html":{"id":"widget_client.js.html","title":"Source: widget/client.js","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Source: widget/client.js api.controller = function($scope, $http, spModal, SPGlideAjax) { /** @module WidgetComponents */ /** * The Angular controller for managing the Action Table * @class module:WidgetComponents.ActionTableController */ /** * Identitifies the localStorage key used for saving and recovering the current state * of the table's rendering. * @property stateKey * @type String * @private */ /** * Time to wait to allow typing to continue before updating the corpus. * @property filterInterval * @default 200 * @type Number * @private */ var stateKey = \"actiontable:state:\" + $scope.options.id, loading = localStorage.getItem(stateKey), filterInterval = 200, fieldTracking = {}, fieldList = [], mapDataFields, clearFault, endReload, filtering, mapFields, saveState, sortData, setIcons, refresh, visible, timing, fillin, fault, x; /** * Save an encoded value of the scope's state value to give persistence to the table's * rendering. * @method module:WidgetComponents.ActionTableController#saveState * @private */ saveState = function() { localStorage.setItem(stateKey, JSON.stringify($scope.state)); }; /** * Updates the icons for various objects for cached rendering purposes * @method module:WidgetComponents.ActionTableController#setIcons */ setIcons = function() { if($scope.columns) { var column; for(x=0; x&lt;$scope.columns.length; x++) { column = $scope.columns[x]; if(column &amp;&amp; !column.no_sort) { if(column.field === $scope.state.order) { if($scope.state.above === 1) { column.sort_icon = \"fa fa-sort-alpha-asc\"; } else { column.sort_icon = \"fa fa-sort-alpha-desc\"; } } else { column.sort_icon = \"fa fa-sort\"; } } } } }; /** * Sorting function used to sort the data.rows array based on the current state values. * @method module:WidgetComponents.ActionTableController#sortData * @param a * @param b */ sortData = function(a, b) { if($scope.state.order) { if(a &amp;&amp; b) { var cA = a[$scope.state.order], cB = b[$scope.state.order]; if(cA &gt; cB) { return $scope.state.above; } else if(cA &lt; cB) { return $scope.state.below; } } else if(a &amp;&amp; !b) { return $scope.state.above; } else if(!a &amp;&amp; b) { return $scope.state.below; } return 0; } }; /** * * @method module:WidgetComponents.ActionTableController#visible * @param {Object} row */ visible = function(row) { return !$scope.state.searching || (row &amp;&amp; typeof(row.$search) === \"string\" &amp;&amp; row.$search.indexOf($scope.state.searching) !== -1); }; /** * Timed function used to balance user typing with when to fire updating the results. * @method module:WidgetComponents.ActionTableController#filtering * @private */ filtering = function() { var now = Date.now(); if(timing &amp;&amp; timing &lt; now) { // Maintain case insensitive search but don't mutate the user input $scope.state.searching = $scope.state.search.toLowerCase(); $scope.state.page = 0; $scope.filterIcon = \"fa-filter\"; $scope.loadCorpus(); $scope.update(); timing = null; saveState(); } else { setTimeout(filtering, filterInterval); } }; /** * Used to keep the data up to date if a refresh interval has been specified. * @method module:WidgetComponents.ActionTableController#refresh * @private */ refresh = function() { if(!isNaN($scope.options.refresh_interval) &amp;&amp; 60000 &lt;= $scope.options.refresh_interval) { $scope.reloadData(); setTimeout(refresh, $scope.options.refresh_interval); } }; /** * Waits 1 second to reset the reload icon to give the visual impact time. * @method module:WidgetComponents.ActionTableController#endReload * @private */ endReload = function() { setTimeout(function() { $scope.reload_icon = \"fa-refresh\"; $scope.update(); }, 1000); }; /** * Use template filling to create a new object whose values mimic the fill object but * with templates completed based on the row. Due to the regular expressions in volved * and the number of search/replacements that can be triggered here, this method should * be used sparingly. * @method module:WidgetComponents.ActionTableController#fillin * @param {Object} fill Object whose values are to be completed * @param {Object} row Source for values */ fillin = function(fill, row) { var keys = Object.keys(fill), result = {}, i; for(i=0; i&lt;keys.length; i++) { result[keys[i]] = $scope.completeTemplate(row, fill[keys[i]]); } return result; }; /** * Internal method for displaying an error that was encountered. * @method module:WidgetComponents.ActionTableController#fault * @private * @param {Error} error That occurred and should be displayed */ fault = function(error) { var message = \"STSTable: Data Request from \"; if($scope.options.data_source == \"ajax\") { message += \"Client Script[\" + $scope.options.script + \".\" + $scope.options.script_method + \"]: \"; } else if($scope.options.data_source == \"snapi\") { message += \"Service-Now API Endpoint[\" + $scope.options.endpoint + \"]: \"; } else { \"Unknown Source: \"; } console.error(message, $scope.error); $scope.error = error; $scope.update(); }; /** * Internal method for clearing an error that had been encountered if one such error exists. * @method module:WidgetComponents.ActionTableController#clearFault * @private */ clearFault = function() { if($scope.error) { $scope.error = null; $scope.update(); } }; /** * Updates the fieldTracking &amp; fieldList properties. * @method module:WidgetComponents.ActionTableController#mapDataFields */ mapDataFields = function() { var i; fieldList.splice(0); if($scope.data.rows &amp;&amp; $scope.data.rows.length) { for(i=0; i&lt;$scope.data.rows.length; i++) { mapFields($scope.data.rows[i]); } } fieldList.push.apply(fieldList, Object.keys(fieldTracking)); }; /** * Checks the object keys to ensure that all fields have a RegExp mapping in the `fieldTracking` * object. * @method module:WidgetComponents.ActionTableController#mapFields * @param {Object} row */ mapFields = function(row) { var keys = Object.keys(row), i; for(i=0; i&lt;keys.length; i++) { if(!fieldTracking[keys[i]]) { fieldTracking[keys[i]] = new RegExp(\"\\\\{\\\\{\" + keys[i] + \"\\\\}\\\\}\", \"ig\"); } } }; // Initialize local data for table management try { $scope.columns = JSON.parse($scope.options.columns); } catch(parseException) { console.error(\"Action Table: Failed to parse column specifications:\", parseException, $scope.options.columns); $scope.error = parseException; } try { $scope.actions = JSON.parse($scope.options.actions); } catch(parseException) { console.error(\"Action Table: Failed to parse action specifications:\", parseException, $scope.options.actions); $scope.error = parseException; } /** * Handles displaying an error to the widget. * * Generally set by calling the private function `fault`. * @property error * @type Error */ if($scope.data.error) { $scope.error = new Error($scope.data.error); } /** * * The displayed icon in the filter to give feedback to the user. * @property filterIcon * @type String */ $scope.filterIcon = \"fa-filter\"; /** * The displayed icon for reloading data to give feedback to the user. * @property filterIcon * @type String */ $scope.reload_icon = \"fa-refresh\"; /** * Each element contained here is an element that is valid after the rows have been * filtered by search and sort criteria. * @property corpus * @type Array */ $scope.corpus = []; /** * Each element contained here is a row to render on the page. This is pared down to * only the rows that should render based on the current page and sourced from the * corpus array to follow search and sort criteria and drive a faster rendering. * @property render * @type Array */ $scope.render = []; /** * Doubles as a page count and rendering array for ng-repeat. * @property pages * @type Array */ $scope.pages = []; // Attempt to recover the previous state of the table, if any /** * * @property state * @type Object */ if(loading) { try { $scope.state = JSON.parse(loading); } catch(loadException) { console.error(\"ActionTable: State Loading Error: \", loadException); $scope.state = {}; } } else { $scope.state = {}; } /** * * @property state.page * @type Number */ if($scope.state.page === undefined) { $scope.state.page = 0; } /** * Used for filtering a row based on the values within it. * @property state.search * @type String */ if($scope.state.search === undefined) { $scope.state.search = \"\"; } /** * The number of rows to display per page. * @property state.size * @type Number */ if(!isNaN($scope.options.per_page) &amp;&amp; $scope.options.per_page &gt; 0) { $scope.state.size = $scope.options.per_page; } else if(isNaN($scope.state.size)) { $scope.state.size = 20; } /** * As \"select\" elements match on strings, a string version of the `state.size` * value is copied here used for user control of the paging size. This is later * in a $watch statement to handle keeping size straight when changed this way. * * Direct modifications to `state.size` after the widget has been created will * NOT currently be reflected back to this value. * @property state.per_page * @type String */ $scope.state.per_page = $scope.state.size.toString(); /** * Names the column by which to sort rows using the field value of the column. * * If the field does not exist, no ordering is explicitly performed. * @property state.order * @type String * @defaul null */ /** * Controls the sort ordering and is returned when `a` is considered to precede `b`. * @property state.above * @type Number * @default -1 */ if($scope.state.above === undefined) { $scope.state.above = -1; } /** * Controls the sort ordering and is returned when `a` is considered to procede `b`. * @property state.below * @type Number * @default 1 */ if($scope.state.below === undefined) { $scope.state.below = -1 * $scope.state.above; } // Cache regular expressions for quick template replacements based on the row's field values mapDataFields(); // When the search string changes, trigger the filtering function to eventually update the rendered values $scope.$watch(\"state.search\", function() { if(!timing) { $scope.filterIcon = \"fa-spinner fa-pulse\"; $scope.update(); filtering(); } timing = Date.now() + 2 * filterInterval; }); // Watch for changes to the size string, likely by the corner select, to push the value into the state and update $scope.$watch(\"state.per_page\", function() { $scope.state.size = parseInt($scope.state.per_page); $scope.loadCorpus(); saveState(); }); /** * Change the direction of sorting or the column to sort by. * * Calling on the currently sorted column toggles the sort direction. * * Changing to a new column does NOT change the sort direction. * @method module:WidgetComponents.ActionTableController#reorder * @param {Object} column */ $scope.reorder = function(column) { if(column) { if($scope.state.order === column.field) { $scope.state.below *= -1; $scope.state.above *= -1; } else { $scope.state.order = column.field; } $scope.loadCorpus(); saveState(); setIcons(); } }; /** * Retrieves data from the server if necessary. * * This is essesntially a stepping method for AJAX sourced data as the other 2 sources * (server script, and table) would already be populated here by the server initialization. * * The SPGlideAjax is heavily favored for the ability to create new configurable data sources * without modifying the widget or its supporting pieces while also keeping the creating of * the data in a more traditionally understood form, Script Includes, instead of passing the * data through a more web traditional method such as an API, where Scripted APIs may get * heavier. Though support for such a process should be added and would also be handled here. * @method module:WidgetComponents.ActionTableController#loadData */ $scope.loadData = function() { var request; clearFault(); switch($scope.options.data_source) { case \"ajax\": request = new SPGlideAjax($scope.options.script); request.addParam(\"sysparm_name\", $scope.options.script_method); request.addParam(\"query\", $scope.options.query); request.getXMLAnswer($scope.receiveData); break; case \"snapi\": if($scope.options.endpoint) { if($scope.options.endpoint[0] !== \"/\") { $scope.options.endpoint = \"/\" + $scope.options.endpoint; } $http.get($scope.options.endpoint + \"?query=\" + $scope.options.query) .then(function(response) { if(response.status === 200) { $scope.receiveData(response.data.result); } else { fault(new Error(\"Malformed request for endpoint data - HTTP\" + response.status + \": \" + response.statusText)); } }, fault); } else { fault(new Error(\"No 'endpoint' option is defined\")); } break; case \"server\": case \"table\": $scope.prepareData(); break; default: console.error(\"Unknown Data Source (data_source) option specified for STSTable widget[\" + $scope.options.id + \"]: \", $scope); $scope.error = { \"message\": \"Unknown Data Source (data_source) option specified for widget.\", \"options\": $scope.options }; } }; /** * Called for receiving the text portion of a request for data. All text is assumed to be a JSON * object with the general format: * ``` * { * \"rows\": [{ * Object 1 Data... * }, { * Object 2 Data... * }, { * ... * {, * Object N Data... * }] * } * ``` * * An object is used to allow for other information to be present on the API call for use later. * @method module:WidgetComponents.ActionTableController#receiveData * @param {String} response */ $scope.receiveData = function(response) { var loading; if(response) { if(typeof(response) === \"string\") { try { loading = JSON.parse(response); } catch(parseException) { fault(parseException); } } else { loading = response; } if(loading &amp;&amp; loading.rows instanceof Array) { $scope.data.rows.splice(0); $scope.data.rows.push.apply($scope.data.rows, loading.rows); $scope.data.loaded = Date.now(); $scope.prepareData(); } else { fault(new Error(\"Receive malformed data, must return a Object JSON with a \\\"rows\\\" property that contains the array to load\")); } } else { fault(new Error(\"Failed to receive any data\")); } }; /** * Essentially prepares the data received from the server. * * This primarily involves setting the `$search` property for easy lower cased * string index checks for filtering based on the columns and `options.filterable`. * * Additionally, the data objectis emitted on the root scope for other widgets to * consume if needed under the event \"ststable:data:[ID]\" where \"[ID]\" is the table's * ID specified in options. This allows another widget on the same page as the table * to implement something akin to `$scope.$on(\"ststable:data:[ID]\", $scope.processAPIData)` * to receive the data and perform any needed actions. * @method module:WidgetComponents.ActionTableController#loadData */ $scope.prepareData = function() { var column, load, row, c, i; if($scope.data.rows) { for(i=0; i&lt;$scope.data.rows.length; i++) { row = $scope.data.rows[i]; row.$search = \"\"; // Ensure that the visible columns are searchable if($scope.options.filterable &amp;&amp; $scope.options.filterable.length) { // Add additional columns that are flagged as filterable in the instance options load = $scope.columns.concat($scope.options.filterable); } else { load = $scope.columns; } for(c=0; c&lt;load.length; c++) { column = load[c]; if(typeof(row[column.field]) === \"string\") { // Map to lower case; Filter is meant to be case insensitive row.$search += \" :: \" + row[column.field].toLowerCase(); } else if(typeof(row[column.field]) === \"object\") { // Handle Field Descriptor data if(row[column.field].display) { row.$search += \" :: \" + row[column.field].display.toLowerCase(); } } else { // Direct Value row.$search += \" :: \" + row[column.field]; } } } $scope.corpus.sort(sortData); } mapDataFields(); $scope.$root.$emit(\"ststable:data:\" + $scope.options.id, $scope.data); $scope.loadCorpus(); }; /** * Filter and sort the general data received from the server. * * This serves as our cache for paging through the data set. * @method module:WidgetComponents.ActionTableController#loadCorpus */ $scope.loadCorpus = function() { $scope.corpus.splice(0); $scope.pages.splice(0); var row, i; if($scope.data.rows) { for(i=0; i&lt;$scope.data.rows.length; i++) { row = $scope.data.rows[i]; if(visible(row)) { $scope.corpus.push(row); } } $scope.corpus.sort(sortData); } $scope.page_count = $scope.corpus.length/$scope.state.size; for(i=0; i&lt;$scope.page_count; i++) { $scope.pages.push(i + 1); } $scope.loadRender(); }; /** * Load data from the `corpus` to the `render` array for the current page being viewed. * @method module:WidgetComponents.ActionTableController#loadRender */ $scope.loadRender = function() { $scope.render.splice(0); var start = $scope.state.page * $scope.state.size, end = start + $scope.state.size, row, i; for(i=start; i&lt;end &amp;&amp; i&lt;$scope.corpus.length; i++) { row = $scope.corpus[i]; if(row) { $scope.render.push(row); } } $scope.update(); }; /** * Sets the page and updates the `render` array for display via the `loadRender` method. * @method module:WidgetComponents.ActionTableController#toPage * @param {Number} page */ $scope.toPage = function(page) { $scope.state.page = page - 1; $scope.loadRender(); saveState(); }; /** * * @method module:WidgetComponents.ActionTableController#getPageClasses * @param {Number} page * @returns {String} */ $scope.getPageClasses = function(page) { if(page -1 === $scope.state.page) { return \"btn-primary\"; } else { return \"btn-default\"; } }; /** * Check if an action is visible based on its `condition` object. * * No condition object indicates it is always visible. * * Condition checking is managed with the `checkConditions` function. * @method module:WidgetComponents.ActionTableController#actionVisible * @param {Object} row * @param {Object} action * @return {Boolean} */ $scope.actionVisible = function(row, action) { if(action.condition) { return $scope.checkCondition(row, action.condition); } return true; }; /** * Process an action object for a row. * @method module:WidgetComponents.ActionTableController#processAction * @param {Object} row * @param {Object} action */ $scope.processAction = function(row, process) { var buffer, keys, i; switch(process.action) { case \"link\": buffer = $scope.completeTemplate(row, process.perform); if(buffer[0] !== \"/\") { buffer = \"/\" + buffer; } location = buffer; break; case \"newlink\": buffer = $scope.completeTemplate(row, process.perform); if(buffer[0] !== \"/\") { buffer = \"/\" + buffer; } window.open(buffer, \"_blank\"); break; case \"form-modal\": process = fillin(process, row); console.log(\"FilledIn: \", process); spModal.open({ \"shared\": $scope.state, \"value\": process, \"title\": process.title, \"widget\": \"widget-form\", \"widgetInput\": process }).then(function (/* button */) { // User clicked \"OK\" - example; button = {\"label\":\"OK\",\"primary\":true,\"focus\":true} }, function(/* error */) { // User clicked \"Cancel\", The close button on the dialog, or clicked outside the box }); break; case \"ajax-call\": process = fillin(process, row); keys = Object.keys(process); buffer = new SPGlideAjax(process.tbl_class); buffer.addParam(\"sysparm_name\", process.tbl_method); for(i=0; i&lt;keys.length; i++) { buffer.addParam(keys[i], process[keys[i]]); } buffer.getXMLAnswer(function(/* response */) { if(process.new_url &amp;&amp; process.new_url[0] !== \"/\") { process.new_url = \"/\" + process.new_url; } switch(process.tbl_complete) { case \"redirect\": location = process.new_url; break; case \"newwindow\": window.open(process.new_url, \"_blank\"); break; } }); break; } }; /** * Get the string to display for the value in row under the column's field value. * @method module:WidgetComponents.ActionTableController#renderValue * @param {Object} row Of data from which to get the value to render. * @param {Object} column Describing what data should be rendered. * @return {String} To place in the table */ $scope.renderValue = function(row, column) { var point = row[column.field], formatting, buffer, value; buffer = typeof(point); if(buffer === \"object\") { formatting = point.type || column.formatting || buffer; value = point.display; } else { formatting = column.formatting || buffer; value = point; } switch(formatting) { case \"time\": buffer = new Date(value); return buffer.toLocaleDateString() + \" \" + buffer.toLocaleTimeString(); case \"date\": buffer = new Date(value); return buffer.toLocaleDateString(); } // Contain runaway decimal point values if(typeof(value) === \"number\" &amp;&amp; value%1) { value = value.toFixed(3); } return value; }; /** * Using a Modal, show the status text for the row. * @method module:WidgetComponents.ActionTableController#viewStatusWarning * @param {Object} row */ $scope.viewStatusWarning = function(row) { spModal.confirm(row.$status_text); }; /** * Performs basic token replacement in a string based on the values in the row object using \"{{...}}\" for replacement * indicators. * * Due to service-now template processing, using \"${...}\" fails without oerly complicated syntax, for example * an option value of \"My name is ${name}\" simply displays as \"My name is name\" and looking at the option value * received to the widget, the value of that option will also be \"My name is name\" because Sevice-Now's templating * has already altered the value. * * Additionally note that the replacement handling is managed with cached regular expressions generated at the start * of this controller. * @method module:WidgetComponents.ActionTableController#completeTemplate * @param {Object} row * @param {String} template * @returns {String} */ $scope.completeTemplate = function(row, template) { for(var i=0; i&lt;fieldList.length; i++) { template = template.replace(fieldTracking[fieldList[i]], row[fieldList[i]] || \"\"); } return template; }; /** * Every field in the condition that is defined must match the corresponding field value in the row, or the * check fails. * @method module:WidgetComponents.ActionTableController#checkCondition * @param {Object} row * @param {Object} condition * @returns {Boolean} */ $scope.checkCondition = function(row, condition) { for(var i=0; i&lt;fieldList.length; i++) { if(condition[fieldList[i]] !== undefined &amp;&amp; condition[fieldList[i]] !== row[fieldList[i]] &amp;&amp; (!row[fieldList[i]] || row[fieldList[i]].value !== condition[fieldList[i]])) { return false; } } return true; }; /** * Get a new array of data from the server and apply it to the current state and render. * @method module:WidgetComponents.ActionTableController#reloadData */ $scope.reloadData = function() { var success, failure; if($scope.options.data_source == \"ajax\") { $scope.loadData(); } else { success = function(response) { $scope.data.rows.splice(0); $scope.data.rows.push.apply($scope.data.rows, response.data.rows); $scope.data.loaded = response.data.loaded; $scope.loadData(); endReload(); }; failure = function(error) { $scope.error = error; endReload(); }; $scope.reload_icon = \"fa-refresh fa-spin\"; $scope.update(); $scope.server.get() .then(success, failure); } }; /** * * @method module:WidgetComponents.ActionTableController#getLastUpdateDisplay * @returns {String} 0 */ $scope.getLastUpdateDisplay = function() { var date = new Date($scope.data.loaded); return date.toLocaleDateString() + \" \" + date.toLocaleTimeString(); }; /** * Forces a re-rendering of AngularJS bindings * @method module:WidgetComponents.ActionTableController#update */ $scope.update = function() { try { $scope.$digest(); } catch(updateException) { // Generally just a digest exception from a current update cycle } }; // Initialize Corpus for rendering based on the loaded state if(!isNaN($scope.options.refresh_interval) &amp;&amp; $scope.options.refresh_interval) { setTimeout(refresh, $scope.options.refresh_interval); } $scope.loadData(); setIcons(); }; × Search results Close "},"widget_server.js.html":{"id":"widget_server.js.html","title":"Source: widget/server.js","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Source: widget/server.js /** * The Angular controller for managing the Action Table * @class module:WidgetComponents.ActionTableServerScript */ (function() { var buffer, i; /** * Object created by Service-Now and passed to the Widget controller on initialization. * @property data * @type Object */ /** * Track when the data was retrieved * @property data.loaded * @type Number */ data.loaded = Date.now(); // Level Set Options if(options.refresh_interval) { options.refresh_interval = parseInt(options.refresh_interval); if(isNaN(options.refresh_interval) || options.refresh_interval &lt; 60000) { options.refresh_interval = 60000; } } if(options.filterable) { options.filterable = options.filterable.split(\",\"); for(i=0; i&lt;options.filterable.length; i++) { options.filterable[i] = options.filterable[i].trim(); } } else { options.filterable = []; } if(options.per_page) { options.per_page = parseInt(options.per_page); } // Retrieve rows based on options try { switch(options.data_source) { /** * Contains the row data for the table * @property data.rows * @type Array */ case \"table\": data.rows = STSTableScriptAPI.getTableData(options.table, options.query); break; case \"server\": if(typeof(STSTableScriptAPI[options.script_method]) == \"function\") { data.rows = STSTableScriptAPI[options.script_method](options.query); } else { buffer = \"Action Table: Script Method \\\"\" + options.script_method + \"\\\" does not exist for Script STSTableScriptAPI\"; gs.error(buffer); throw new Error(buffer); } break; case \"snapi\": case \"ajax\": // Handled Client Side data.rows = []; break; default: gs.error(\"Action Table: Unknown Data Source: \" + options.data_source); } } catch(sourceException) { /** * Message from an error while building the data for the table * @property data.error * @type String */ data.error = sourceException.message || \"Generic Error occurred\"; gs.error(sourceException); } })(); × Search results Close "},"providers_spglideajax.js.html":{"id":"providers_spglideajax.js.html","title":"Source: providers/spglideajax.js","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Source: providers/spglideajax.js function SPGlideAjax($http) { /** @module AngularProviders */ /** * A simplified version of GlideAJAX for use within the Service Portal. * * This specifically implements getAnswer and getXMLAnswer with some modernization * for Promise support through Angular's $http service. * @class module:AngularProviders.SPGlideAjax * @param {$http} $http * @example * // Script Include * var Example = Class.create(); * Example.prototype = Object.extendsObject(AbstractAjaxProcessor, { * \"type\": \"Example\", * \"functionA\": function() { * return this.getParameter(\"a\"); * } * }); * * // Client Script * function _controller($scope, SPGlideAjax) { * var ga = new SPGlideAjax(\"Example\"); * ga.addParam(\"sysparm_name\", \"functionA\"); * ga.addParam(\"a\", 9); * // (This will print \"9\" as a warning to the browser's console) * ga.getXMLAnswer(console.warn); *} */ /** * Static space reference for quick replacement. * @property regexSpace * @type RegExp * @priavte * @static */ var regexSpace = / /g; /** * Service-Now's GlideAjax works with form data strings instead of JSON, * so this is used to convert the parameters to the appropriate format. * @method module:AngularProviders.SPGlideAjax#serializeToForm * @priavte * @static * @param {Object} data The object to parse into form data. The values off the object * should be easily represented as strings or issues may occur. * @return {String} Form data string of the data in the passed object */ var serializeToForm = function(data) { var keys = Object.keys(data), encoding = [], x; for (x = 0; x &lt; keys.length; x++) { encoding.push(encodeURIComponent(keys[x]) + \"=\" + encodeURIComponent(data[keys[x]] ? data[keys[x]].toString() : \"\")); } return encoding.join(\"&amp;\").replace(regexSpace, \"+\"); }; /** * General options to use with all $HTTP calls * @property generalOptions * @type Object * @private * @static */ var generalOptions = { \"headers\": { \"content-type\": \"application/x-www-form-urlencoded; charset=utf-8\" } }; // The actual class constructor returned by the Factory declaration in Angular return function(processor) { var factory = this, parameters = {}; parameters.sysparm_processor = processor; parameters.sysparm_scope = \"global\"; parameters.sysparm_want_session_messages = \"true\"; /** * Uses the parameters object to handle processing. * * If the sysparm_name property is missing, a warning is sent to the * console for developer awareness. * @method module:AngularProviders.SPGlideAjax#getAnswer * @param {Function} callback Takes callback(answer, error) and resolves appropriately * the same as the returned promise. * @return {Promise} The promise resolves with the answer XML element on * success or an Error object on failure. */ this.getAnswer = function(callback) { if (!parameters.sysparm_name) { console.warn(\"GlideAJAX call with no sysparm_name defined; Call addParam('sysparm_name', '[ScriptInclude Method Name]') prior to calling getXMLAnswer\"); } return $http.post(\"/xmlhttp.do\", serializeToForm(parameters), generalOptions) .then(function(response) { var el = $(response.data), answer; if (el &amp;&amp; el.length &gt;= 2 &amp;&amp; el[1].getAttribute) { answer = el[1]; if (callback) { callback(answer); } return answer; } else { if (callback) { callback(null); } return null; } }); }; /** * Sets a parameter for a pending AJAX request. * @method module:AngularProviders.SPGlideAjax#addParam * @param {String} field The name of the field to be passed. * @param {String} value The value to be passed for that field. */ this.addParam = function(field, value) { parameters[field] = value; }; /** * Get the answer property from the returned XML. * @method module:AngularProviders.SPGlideAjax#getXMLAnswer * @param {Function} callback Takes callback(answer, error) and resolves appropriately * the same as the returned promise. * @return {Promise} Resolves on success with the answer string and on failure * throws to the catch chain. */ this.getXMLAnswer = function(callback) { return factory.getAnswer() .then(function(answer) { if (answer &amp;&amp; answer.getAttribute) { answer = answer.getAttribute(\"answer\"); } else { answer = null; } if (!answer) { answer = null; } if (callback) { callback(answer); } }, callback); }; }; } × Search results Close "},"scripts_include.js.html":{"id":"scripts_include.js.html","title":"Source: scripts/include.js","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Source: scripts/include.js /** @module ScriptIncludes */ var ActionTableScriptAPI = Class.create(); /** * Contains assistive methods for working with the ActionTable widget and acts as * an anchor point for leveraging server-side data with script includes while not * using the SPGlideAJAX functionality. * * Note that ActionTable supports pulling data from a client callable script include * as well as leveraging the REST API (Though authentication may pose issues with REST). * * Extending this class instead of AbstractAjaxProcessor is not necessary from a * functionality perspective, but does help to track or imply why that script * exists. * @class module:ScriptIncludes.ActionTableScriptAPI */ ActionTableScriptAPI.prototype = Object.extendsObject(AbstractAjaxProcessor, { \"type\": \"ActionTableScriptAPI\", \"getFieldDescription\": ActionTableScriptAPI.getFieldDescription, \"finishQuery\": ActionTableScriptAPI.finishQuery, \"toJSON\": ActionTableScriptAPI.toJSON }); /** * Takes a general query and flushes out the record data with field descriptors. * @method module:ScriptIncludes.ActionTableScriptAPI#finishQuery * @static * @param {GlideRecord} queried That has the search parameters entered and `query()` * has been called. * @return {Array} With */ ActionTableScriptAPI.finishQuery = function(queried) { var result = [], build, keys, key, i; if(queried.next()) { keys = Object.keys(queried); do { build = {}; for(i=0; i&lt;keys.length; i++) { key = keys[i]; build[key] = ActionTableScriptAPI.getFieldDescription(queried, key); } result.push(build); } while(queried.next()); } return result; }; /** * Retrieve the value for the field along with additional descriptive information about the field * in an object to add to the row data. * * This does create somewhat of a duplication of data as this extra data will be the same across * several rows. * @method module:ScriptIncludes.ActionTableScriptAPI#getFieldDescription * @static * @param {GlideRecord} record * @param {String} name * @returns {Object} With properties; display_value, value, type, label */ ActionTableScriptAPI.getFieldDescription = function(record, name) { var element = record.getElement(name), field = {}; field.display_value = record.getDisplayValue(name); field.value = record.getValue(name); if(record) { field.type = element.getED().getInternalType(); field.label = element.getLabel(); } field.display = field.display_value; field.descriptive = true; return field; }; /** * Convert a GlideRecord's data to JSON. * * This method does _NOT_ use `getFieldDescription` as that isn't the expected mode for * the ActionTable widget. If looking for more flushed out data, use the `finishQuery` * method instead. * @method module:ScriptIncludes.ActionTableScriptAPI#toJSON * @static * @param {GlideRecord} record * @return {Object} */ ActionTableScriptAPI.toJSON = function (record, raw) { raw = raw || {}; var keys = Object.keys(record), json = {}, i; json.$search = \"\"; if (typeof (record.getValue) === \"function\") { for (i = 0; i &lt; keys.length; i++) { json[keys[i]] = raw[keys[i]] ? record.getValue(keys[i]) : record.getDisplayValue(keys[i]); } } else { for (i = 0; i &lt; keys.length; i++) { json[keys[i]] = record[keys[i]]; } } return json; }; /** * Pull general data from a table. * @method module:ScriptIncludes.ActionTableScriptAPI#getTableData * @param {String} table To query * @param {String} query Encoded Query to pass into the query. * @param {Number} [page_size] Optional limiter for number of rows to retrieve. * @param {Number} [page] Optional offset for getting a specific page of data. * @return {Array} Of records. */ ActionTableScriptAPI.prototype.getTableData = ActionTableScriptAPI.getTableData = function (table, query, page_size, page) { var search = new GlideRecord(table), offset = page * page_size, result = [], i; search.addEncodedQuery(query); search.query(); if (search.hasNext()) { for (i = 0; i &lt; offset; i++) { search.next(); } while (search.next()) { result.push(ActionTableScriptAPI.toJSON(search)); } } return result; }; /** * Returns non-persistent random data; If a page is requested twice, the data will not be the same. * * Uses page_size to gauge the amount of data to generate. * @method module:ScriptIncludes.ActionTableScriptAPI#generateExampleData * @static * @param {String} filter * @param {Number} page_size Defaults to 30 * @return {Array} Length either 5 * page_size or 30 of semi-random. */ ActionTableScriptAPI.generateExampleData = function (filter, page_size) { var result = [], amount; if(page_size) { amount = page_size * 10; } else { amount = 30; } for (var i = 0; i &lt; amount; i++) { result.push(ActionTableScriptAPI.toJSON({ \"name\": \"Name Test \" + i, \"short_description\": \"Short Description \" + i, \"sys_id\": \"abcd_\" + i, \"state\": Math.random() &lt; .3 ? \"inactive\" : \"active\" })); } return result; }; /** * Returns non-persistent random data; If a page is requested twice, the data will not be the same. * * Uses page_size to gauge the amount of data to generate. * @method module:ScriptIncludes.ActionTableScriptAPI#getExampleData * @param {String} filter * @param {Number} page_size Defaults to 30 * @return {Array} Length either 5 * page_size or 30 of semi-random. */ ActionTableScriptAPI.prototype.getExampleData = function(filter, page_size) { page_size = page_size || this.getParameter(\"page_size\"); filter = filter || this.getParameter(\"filter\"); return JSON.stringify({ \"rows\": ActionTableScriptAPI.generateExampleData(filter, page_size) }); }; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Modules Classes SPGlideAjax ActionTableScriptAPI ActionTableController ActionTableServerScript × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Classes Classes SPGlideAjax ActionTableScriptAPI ActionTableController ActionTableServerScript × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Action Table A configurable table widget designed to pull data from scripts or tables and provide an instance option way to configure conditional buttons for each row. Quick Setup The easiest way to setup data for the table while keeping your update set contained is with a client callable script include. Create the Script Include In your instance start a new Script Include ( /sys_script_include.do?sys_id=-1 ) Enable \"Client Callable\" Setup the method that will return the data to return a JSON string of the array Setup any methods you wish to be called from buttons on the table (if any) Configure the Widget Instance Set the Data source as \"Client Callable Script\" For \"Client Script to Call\" enter the name of the script you created For \"Script Method for Data\" enter the name of the method from the script that returns the data For \"Columns JSON\" enter a JSON array of objects describing a \"label\" and a \"field\". The label is displayed in the header and the field is the field from the returned data objects to be displayed in the cell. As an example; [ { \"label\": \"Name\", \"field\": \"name\" }, { \"label\": \"Short Description\", \"field\": \"short_description\" } ] For the \"Actions JSON\" enter JSON describing the action that can be provided to a row. These may have simple conditions mapping a field name to a specific value where the action is only visible when all parts of the condition object match. As an example; [ { \"label\": \"Activate {{name}}\", \"field\": \"name\", \"action\": \"link\", \"title\": \"Activate {{name}}\", \"classes\": \"btn btn-success\", \"perform\": \"/incident.do?sys_id=-1&amp;test={{sys_id}}\", \"condition\": { \"state\": \"inactive\" } }, { \"label\": \"Deactivate {{name}}\", \"field\": \"name\", \"action\": \"link\", \"title\": \"Deactivate {{name}}\", \"classes\": \"btn btn-warning\", \"perform\": \"/incident.do?sys_id=-1&amp;test={{sys_id}}\", \"condition\": { \"state\": \"active\" } } ] Fill out any other options as desired (See their help text). They are not required. Additional Actions The action object has a few set fields that the widget uses to display the data and each action has additional fields that it uses. Each field that's used is usually updated with template replacements, thus in the above examples, {{name}} is replaced with the name field from the object for that row, and the {{sys_id}} value for the url allows creaiton of specific links. Each object has a few key values specific to rendering the button: icon With classes specifically for rendering an icon. This will generally follow font-awesome 4.7 or another glyph set included on your portal label For the displayed text title Used for hover text (HTML title property) on the button icon Containing a string of CSS classes to set on the button condition Optional object describing values that have to match for the action to display action Indicating how interactions with this action should process. The action field describes what kind of action is taken when the button is pressed and has a few options: link or newlink go to a URL. newlink doing so in a new window or tab. Example: { \"label\": \"Activate {{name}}\", \"action\": \"link\", \"title\": \"Activate {{name}}\", \"classes\": \"btn btn-success\", \"perform\": \"/incident.do?sys_id=-1&amp;test={{sys_id}}\", \"condition\": { \"state\": \"inactive\" } } form-modal opens a modal on the page with a form view. Every key's value is filled in for the object passed to the modal. This action also uses several specific extra key values; table, sys_id, and view to specify the form to open. These values are template completed before being invoked. Example: { \"label\": \"\", \"title\": \"{{name}}\", \"action\": \"form-modal\", \"classes\": \"btn btn-primary\", \"icon\": \"fa fa-info-circle\", \"table\": \"sys_user\", \"sys_id\": \"{{sys_id}}\", \"view\": \"default\" } ajax-call makes an AJAX call similar to a GlideAjax call. This action also fills out the key values for all keys on the object and then passes each key as a parameter in the AJAX call. The tbl_class is used to initialize the SPGlideAjax instance and tbl_method is specifically added as the \"sysparm_name\" parameter of the AJAX call. Both keys can also be specified specifically as a key:value pair on the row's data that can be completed for a more dynamic AJAX call. Additionally, a tbl_complete key is used for a switch case that can be eithe rredirect or newwindow and will use the new_url key to open or redirect once a response is received. However, as a note, deeply nested data will NOT get replacements. Example: { \"label\": \"Call AJAX\", \"title\": \"Activate {{name}}\", \"classes\": \"btn btn-success\", \"action\": \"ajax\", \"tbl_method\": \"ClientCallableScript\", \"tbl_method\": \"ScriptFunction\", \"some_data_for_the_function\": \"{{sys_id}}\", \"quick_note\": { \"this_will_NOT_be_replaced\": \"{{name}}\" } } × Search results Close "},"module-AngularProviders.html":{"id":"module-AngularProviders.html","title":"Module: AngularProviders","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Module: AngularProviders Source: providers/spglideajax.js, line 2 Classes SPGlideAjax × Search results Close "},"module-AngularProviders.SPGlideAjax.html":{"id":"module-AngularProviders.SPGlideAjax.html","title":"Class: SPGlideAjax","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Class: SPGlideAjax AngularProviders. SPGlideAjax new SPGlideAjax($http) A simplified version of GlideAJAX for use within the Service Portal. This specifically implements getAnswer and getXMLAnswer with some modernization for Promise support through Angular's $http service. Parameters: Name Type Description $http $http Source: providers/spglideajax.js, line 4 Example // Script Include var Example = Class.create(); Example.prototype = Object.extendsObject(AbstractAjaxProcessor, { \"type\": \"Example\", \"functionA\": function() { return this.getParameter(\"a\"); } }); // Client Script function _controller($scope, SPGlideAjax) { var ga = new SPGlideAjax(\"Example\"); ga.addParam(\"sysparm_name\", \"functionA\"); ga.addParam(\"a\", 9); // (This will print \"9\" as a warning to the browser's console) ga.getXMLAnswer(console.warn); } Methods addParam(field, value) Sets a parameter for a pending AJAX request. Parameters: Name Type Description field String The name of the field to be passed. value String The value to be passed for that field. Source: providers/spglideajax.js, line 118 getAnswer(callback) Uses the parameters object to handle processing. If the sysparm_name property is missing, a warning is sent to the console for developer awareness. Parameters: Name Type Description callback function Takes callback(answer, error) and resolves appropriately the same as the returned promise. Source: providers/spglideajax.js, line 83 Returns: The promise resolves with the answer XML element on success or an Error object on failure. Type Promise getXMLAnswer(callback) Get the answer property from the returned XML. Parameters: Name Type Description callback function Takes callback(answer, error) and resolves appropriately the same as the returned promise. Source: providers/spglideajax.js, line 128 Returns: Resolves on success with the answer string and on failure throws to the catch chain. Type Promise serializeToForm(data) Service-Now's GlideAjax works with form data strings instead of JSON, so this is used to convert the parameters to the appropriate format. Parameters: Name Type Description data Object The object to parse into form data. The values off the object should be easily represented as strings or issues may occur. Source: providers/spglideajax.js, line 40 Returns: Form data string of the data in the passed object Type String × Search results Close "},"module-ScriptIncludes.html":{"id":"module-ScriptIncludes.html","title":"Module: ScriptIncludes","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Module: ScriptIncludes Source: scripts/include.js, line 1 Classes ActionTableScriptAPI × Search results Close "},"module-ScriptIncludes.ActionTableScriptAPI.html":{"id":"module-ScriptIncludes.ActionTableScriptAPI.html","title":"Class: ActionTableScriptAPI","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Class: ActionTableScriptAPI ScriptIncludes. ActionTableScriptAPI new ActionTableScriptAPI() Contains assistive methods for working with the ActionTable widget and acts as an anchor point for leveraging server-side data with script includes while not using the SPGlideAJAX functionality. Note that ActionTable supports pulling data from a client callable script include as well as leveraging the REST API (Though authentication may pose issues with REST). Extending this class instead of AbstractAjaxProcessor is not necessary from a functionality perspective, but does help to track or imply why that script exists. Source: scripts/include.js, line 3 Methods finishQuery(queried) Takes a general query and flushes out the record data with field descriptors. Parameters: Name Type Description queried GlideRecord That has the search parameters entered and query() has been called. Source: scripts/include.js, line 23 Returns: With Type Array generateExampleData(filter, page_size) Returns non-persistent random data; If a page is requested twice, the data will not be the same. Uses page_size to gauge the amount of data to generate. Parameters: Name Type Description filter String page_size Number Defaults to 30 Source: scripts/include.js, line 142 Returns: Length either 5 * page_size or 30 of semi-random. Type Array getExampleData(filter, page_size) Returns non-persistent random data; If a page is requested twice, the data will not be the same. Uses page_size to gauge the amount of data to generate. Parameters: Name Type Description filter String page_size Number Defaults to 30 Source: scripts/include.js, line 174 Returns: Length either 5 * page_size or 30 of semi-random. Type Array getFieldDescription(record, name) Retrieve the value for the field along with additional descriptive information about the field in an object to add to the row data. This does create somewhat of a duplication of data as this extra data will be the same across several rows. Parameters: Name Type Description record GlideRecord name String Source: scripts/include.js, line 54 Returns: With properties; display_value, value, type, label Type Object getTableData(table, query [, page_size] [, page]) Pull general data from a table. Parameters: Name Type Argument Description table String To query query String Encoded Query to pass into the query. page_size Number &lt;optional&gt; Optional limiter for number of rows to retrieve. page Number &lt;optional&gt; Optional offset for getting a specific page of data. Source: scripts/include.js, line 113 Returns: Of records. Type Array toJSON(record) Convert a GlideRecord's data to JSON. This method does NOT use getFieldDescription as that isn't the expected mode for the ActionTable widget. If looking for more flushed out data, use the finishQuery method instead. Parameters: Name Type Description record GlideRecord Source: scripts/include.js, line 82 Returns: Type Object × Search results Close "},"module-WidgetComponents.html":{"id":"module-WidgetComponents.html","title":"Module: WidgetComponents","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Module: WidgetComponents Source: widget/client.js, line 2 Classes ActionTableController ActionTableServerScript × Search results Close "},"module-WidgetComponents.ActionTableController.html":{"id":"module-WidgetComponents.ActionTableController.html","title":"Class: ActionTableController","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Class: ActionTableController WidgetComponents. ActionTableController new ActionTableController() The Angular controller for managing the Action Table Source: widget/client.js, line 3 Methods actionVisible(row, action) Check if an action is visible based on its condition object. No condition object indicates it is always visible. Condition checking is managed with the checkConditions function. Parameters: Name Type Description row Object action Object Source: widget/client.js, line 643 Returns: Type Boolean checkCondition(row, condition) Every field in the condition that is defined must match the corresponding field value in the row, or the check fails. Parameters: Name Type Description row Object condition Object Source: widget/client.js, line 796 Returns: Type Boolean &lt;private&gt; clearFault() Internal method for clearing an error that had been encountered if one such error exists. Source: widget/client.js, line 184 completeTemplate(row, template) Performs basic token replacement in a string based on the values in the row object using \"{{...}}\" for replacement indicators. Due to service-now template processing, using \"${...}\" fails without oerly complicated syntax, for example an option value of \"My name is ${name}\" simply displays as \"My name is name\" and looking at the option value received to the widget, the value of that option will also be \"My name is name\" because Sevice-Now's templating has already altered the value. Additionally note that the replacement handling is managed with cached regular expressions generated at the start of this controller. Parameters: Name Type Description row Object template String Source: widget/client.js, line 773 Returns: Type String &lt;private&gt; endReload() Waits 1 second to reset the reload icon to give the visual impact time. Source: widget/client.js, line 136 &lt;private&gt; fault(error) Internal method for displaying an error that was encountered. Parameters: Name Type Description error Error That occurred and should be displayed Source: widget/client.js, line 165 fillin(fill, row) Use template filling to create a new object whose values mimic the fill object but with templates completed based on the row. Due to the regular expressions in volved and the number of search/replacements that can be triggered here, this method should be used sparingly. Parameters: Name Type Description fill Object Object whose values are to be completed row Object Source for values Source: widget/client.js, line 147 &lt;private&gt; filtering() Timed function used to balance user typing with when to fire updating the results. Source: widget/client.js, line 105 getLastUpdateDisplay() Source: widget/client.js, line 844 Returns: 0 Type String getPageClasses(page) Parameters: Name Type Description page Number Source: widget/client.js, line 629 Returns: Type String loadCorpus() Filter and sort the general data received from the server. This serves as our cache for paging through the data set. Source: widget/client.js, line 566 loadData() Retrieves data from the server if necessary. This is essesntially a stepping method for AJAX sourced data as the other 2 sources (server script, and table) would already be populated here by the server initialization. The SPGlideAjax is heavily favored for the ability to create new configurable data sources without modifying the widget or its supporting pieces while also keeping the creating of the data in a more traditionally understood form, Script Includes, instead of passing the data through a more web traditional method such as an API, where Scripted APIs may get heavier. Though support for such a process should be added and would also be handled here. Source: widget/client.js, line 409 loadData() Essentially prepares the data received from the server. This primarily involves setting the $search property for easy lower cased string index checks for filtering based on the columns and options.filterable. Additionally, the data objectis emitted on the root scope for other widgets to consume if needed under the event \"ststable:data:[ID]\" where \"[ID]\" is the table's ID specified in options. This allows another widget on the same page as the table to implement something akin to $scope.$on(\"ststable:data:[ID]\", $scope.processAPIData) to receive the data and perform any needed actions. Source: widget/client.js, line 510 loadRender() Load data from the corpus to the render array for the current page being viewed. Source: widget/client.js, line 596 mapDataFields() Updates the fieldTracking &amp; fieldList properties. Source: widget/client.js, line 195 mapFields(row) Checks the object keys to ensure that all fields have a RegExp mapping in the fieldTracking object. Parameters: Name Type Description row Object Source: widget/client.js, line 211 processAction(row, action) Process an action object for a row. Parameters: Name Type Description row Object action Object Source: widget/client.js, line 661 receiveData(response) Called for receiving the text portion of a request for data. All text is assumed to be a JSON object with the general format: { \"rows\": [{ Object 1 Data... }, { Object 2 Data... }, { ... {, Object N Data... }] } An object is used to allow for other information to be present on the API call for use later. Parameters: Name Type Description response String Source: widget/client.js, line 463 &lt;private&gt; refresh() Used to keep the data up to date if a refresh interval has been specified. Source: widget/client.js, line 125 reloadData() Get a new array of data from the server and apply it to the current state and render. Source: widget/client.js, line 813 renderValue(row, column) Get the string to display for the value in row under the column's field value. Parameters: Name Type Description row Object Of data from which to get the value to render. column Object Describing what data should be rendered. Source: widget/client.js, line 727 Returns: To place in the table Type String reorder(column) Change the direction of sorting or the column to sort by. Calling on the currently sorted column toggles the sort direction. Changing to a new column does NOT change the sort direction. Parameters: Name Type Description column Object Source: widget/client.js, line 386 &lt;private&gt; saveState() Save an encoded value of the scope's state value to give persistence to the table's rendering. Source: widget/client.js, line 41 setIcons() Updates the icons for various objects for cached rendering purposes Source: widget/client.js, line 50 sortData(a, b) Sorting function used to sort the data.rows array based on the current state values. Parameters: Name Type Description a b Source: widget/client.js, line 73 toPage(page) Sets the page and updates the render array for display via the loadRender method. Parameters: Name Type Description page Number Source: widget/client.js, line 618 update() Forces a re-rendering of AngularJS bindings Source: widget/client.js, line 854 viewStatusWarning(row) Using a Modal, show the status text for the row. Parameters: Name Type Description row Object Source: widget/client.js, line 764 visible(row) Parameters: Name Type Description row Object Source: widget/client.js, line 97 × Search results Close "},"module-WidgetComponents.ActionTableServerScript.html":{"id":"module-WidgetComponents.ActionTableServerScript.html","title":"Class: ActionTableServerScript","body":" DocStrap Modules AngularProvidersScriptIncludesWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScript Class: ActionTableServerScript WidgetComponents. ActionTableServerScript new ActionTableServerScript() The Angular controller for managing the Action Table Source: widget/server.js, line 1 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
