<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"widget_client.js.html":{"id":"widget_client.js.html","title":"Source: widget/client.js","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Source: widget/client.js api.controller = function($scope, $http, spModal, SPGlideAjax) { /** * The Angular controller for managing the Action Table * @class module:WidgetComponents.ActionTableController */ /** * Identitifies the localStorage key used for saving and recovering the current state * of the table's rendering. * @memberof ActionTableController * @type {String} * @alias stateKey * @private */ var stateKey = \"actiontable:state:\" + $scope.options.id, loading = localStorage.getItem(stateKey), /** * Time to wait to allow typing to continue before updating the corpus. * @property {Number} filterInterval * @memberof ActionTableController * @default 200 * * @private */ filterInterval = 200, fieldTracking = {}, fieldList = [], mapDataFields, clearFault, endReload, filtering, mapFields, saveState, sortData, setIcons, refresh, visible, timing, fillin, fault, x; /** * Save an encoded value of the scope's state value to give persistence to the table's * rendering. * @method module:WidgetComponents.ActionTableController#saveState * @private */ saveState = function() { localStorage.setItem(stateKey, JSON.stringify($scope.state)); }; /** * Updates the icons for various objects for cached rendering purposes * @method module:WidgetComponents.ActionTableController#setIcons */ setIcons = function() { if($scope.columns) { var column; for(x=0; x&lt;$scope.columns.length; x++) { column = $scope.columns[x]; if(column &amp;&amp; !column.no_sort) { if(column.field === $scope.state.order) { if($scope.state.above === 1) { column.sort_icon = \"fa fa-sort-alpha-asc\"; } else { column.sort_icon = \"fa fa-sort-alpha-desc\"; } } else { column.sort_icon = \"fa fa-sort\"; } } } } }; /** * Sorting function used to sort the data.rows array based on the current state values. * @method module:WidgetComponents.ActionTableController#sortData * @param a * @param b */ sortData = function(a, b) { if($scope.state.order) { if(a &amp;&amp; b) { var cA = a[$scope.state.order], cB = b[$scope.state.order]; if(cA &gt; cB) { return $scope.state.above; } else if(cA &lt; cB) { return $scope.state.below; } } else if(a &amp;&amp; !b) { return $scope.state.above; } else if(!a &amp;&amp; b) { return $scope.state.below; } return 0; } }; /** * * @method module:WidgetComponents.ActionTableController#visible * @param {Object} row */ visible = function(row) { return !$scope.state.searching || (row &amp;&amp; typeof(row.$search) === \"string\" &amp;&amp; row.$search.indexOf($scope.state.searching) !== -1); }; /** * Timed function used to balance user typing with when to fire updating the results. * @method module:WidgetComponents.ActionTableController#filtering * @private */ filtering = function() { var now = Date.now(); if(timing &amp;&amp; timing &lt; now) { // Maintain case insensitive search but don't mutate the user input $scope.state.searching = $scope.state.search.toLowerCase(); $scope.state.page = 0; $scope.filterIcon = \"fa-filter\"; $scope.loadCorpus(); $scope.update(); timing = null; saveState(); } else { setTimeout(filtering, filterInterval); } }; /** * Used to keep the data up to date if a refresh interval has been specified. * @method module:WidgetComponents.ActionTableController#refresh * @private */ refresh = function() { if(!isNaN($scope.options.refresh_interval) &amp;&amp; 60000 &lt;= $scope.options.refresh_interval) { $scope.reloadData(); setTimeout(refresh, $scope.options.refresh_interval); } }; /** * Waits 1 second to reset the reload icon to give the visual impact time. * @method module:WidgetComponents.ActionTableController#endReload * @private */ endReload = function() { setTimeout(function() { $scope.reloadIcon = \"fa-refresh\"; $scope.update(); }, 1000); }; /** * Use template filling to create a new object whose values mimic the fill object but * with templates completed based on the row. Due to the regular expressions in volved * and the number of search/replacements that can be triggered here, this method should * be used sparingly. * @method module:WidgetComponents.ActionTableController#fillin * @param {Object} fill Object whose values are to be completed * @param {Object} row Source for values */ fillin = function(fill, row) { var keys = Object.keys(fill), result = {}, i; for(i=0; i&lt;keys.length; i++) { result[keys[i]] = $scope.completeTemplate(row, fill[keys[i]]); } return result; }; /** * Internal method for displaying an error that was encountered. * @method module:WidgetComponents.ActionTableController#fault * @private * @param {Error} error That occurred and should be displayed */ fault = function(error) { var message = \"STSTable: Data Request from \"; if($scope.options.data_source == \"ajax\") { message += \"Client Script[\" + $scope.options.script + \".\" + $scope.options.script_method + \"]: \"; } else if($scope.options.data_source == \"snapi\") { message += \"Service-Now API Endpoint[\" + $scope.options.endpoint + \"]: \"; } else { \"Unknown Source: \"; } console.error(message, $scope.error); $scope.error = error; $scope.update(); }; /** * Internal method for clearing an error that had been encountered if one such error exists. * @method module:WidgetComponents.ActionTableController#clearFault * @private */ clearFault = function() { if($scope.error) { $scope.error = null; $scope.update(); } }; /** * Updates the fieldTracking &amp; fieldList properties. * @method module:WidgetComponents.ActionTableController#mapDataFields */ mapDataFields = function() { var i; fieldList.splice(0); if($scope.data.rows &amp;&amp; $scope.data.rows.length) { for(i=0; i&lt;$scope.data.rows.length; i++) { mapFields($scope.data.rows[i]); } } fieldList.push.apply(fieldList, Object.keys(fieldTracking)); }; /** * Checks the object keys to ensure that all fields have a RegExp mapping in the `fieldTracking` * object. * @method module:WidgetComponents.ActionTableController#mapFields * @param {Object} row */ mapFields = function(row) { var keys = Object.keys(row), i; for(i=0; i&lt;keys.length; i++) { if(!fieldTracking[keys[i]]) { fieldTracking[keys[i]] = new RegExp(\"\\\\{\\\\{\" + keys[i] + \"\\\\}\\\\}\", \"ig\"); } } }; // Initialize local data for table management try { $scope.columns = JSON.parse($scope.options.columns); } catch(parseException) { console.error(\"Action Table: Failed to parse column specifications:\", parseException, $scope.options.columns); $scope.error = parseException; } try { $scope.actions = JSON.parse($scope.options.actions); } catch(parseException) { console.error(\"Action Table: Failed to parse action specifications:\", parseException, $scope.options.actions); $scope.error = parseException; } if($scope.data.error) { /** * Handles displaying an error to the widget. * * Generally set by calling the private function `fault`. * @memberof module:WidgetComponents.ActionTableController * @type {Object} * @alias error * */ $scope.error = new Error($scope.data.error); } /** * * The displayed icon in the filter to give feedback to the user. * @memberof module:WidgetComponents.ActionTableController * @type {String} * @alias filterIcon */ $scope.filterIcon = \"fa-filter\"; /** * The displayed icon for reloading data to give feedback to the user. * @memberof module:WidgetComponents.ActionTableController * @type {String} * @alias reloadIcon */ $scope.reloadIcon = \"fa-refresh\"; /** * Each element contained here is an element that is valid after the rows have been * filtered by search and sort criteria. * @memberof module:WidgetComponents.ActionTableController * @type {Array} * @alias corpus */ $scope.corpus = []; /** * Each element contained here is a row to render on the page. This is pared down to * only the rows that should render based on the current page and sourced from the * corpus array to follow search and sort criteria and drive a faster rendering. * @memberof module:WidgetComponents.ActionTableController * @type {Array} * @alias render * */ $scope.render = []; /** * Doubles as a page count and rendering array for ng-repeat. * @memberof module:WidgetComponents.ActionTableController * @type {Array} * @alias pages */ $scope.pages = []; // Attempt to recover the previous state of the table, if any if(loading) { try { /** * Holds the stateful data for the widget that should be tracked and * reloaded on refresh. This is specifically accomplished by calls * to `saveState` in combination with a `$watch` specification. * @memberof module:WidgetComponents.ActionTableController * @type {State} * @link State * @alias state */ $scope.state = JSON.parse(loading); } catch(loadException) { console.error(\"ActionTable: State Loading Error: \", loadException); $scope.state = {}; } } else { $scope.state = {}; } if($scope.state.page === undefined) { $scope.state.page = 0; } if($scope.state.search === undefined) { $scope.state.search = \"\"; } if(!isNaN($scope.options.per_page) &amp;&amp; $scope.options.per_page &gt; 0) { $scope.state.size = $scope.options.per_page; } else if(isNaN($scope.state.size)) { $scope.state.size = 20; } $scope.state.per_page = $scope.state.size.toString(); if($scope.state.above === undefined) { $scope.state.above = -1; } if($scope.state.below === undefined) { $scope.state.below = -1 * $scope.state.above; } // Cache regular expressions for quick template replacements based on the row's field values mapDataFields(); // When the search string changes, trigger the filtering function to eventually update the rendered values $scope.$watch(\"state.search\", function() { if(!timing) { $scope.filterIcon = \"fa-spinner fa-pulse\"; $scope.update(); filtering(); } timing = Date.now() + 2 * filterInterval; }); // Watch for changes to the size string, likely by the corner select, to push the value into the state and update $scope.$watch(\"state.per_page\", function() { $scope.state.size = parseInt($scope.state.per_page); $scope.loadCorpus(); saveState(); }); /** * Change the direction of sorting or the column to sort by. * * Calling on the currently sorted column toggles the sort direction. * * Changing to a new column does NOT change the sort direction. * @method module:WidgetComponents.ActionTableController#reorder * @param {Column} column */ $scope.reorder = function(column) { if(column) { if($scope.state.order === column.field) { $scope.state.below *= -1; $scope.state.above *= -1; } else { $scope.state.order = column.field; } $scope.loadCorpus(); saveState(); setIcons(); } }; /** * Retrieves data from the server if necessary. * * This is essesntially a stepping method for AJAX sourced data as the other 2 sources * (server script, and table) would already be populated here by the server initialization. * * The SPGlideAjax is heavily favored for the ability to create new configurable data sources * without modifying the widget or its supporting pieces while also keeping the creating of * the data in a more traditionally understood form, Script Includes, instead of passing the * data through a more web traditional method such as an API, where Scripted APIs may get * heavier. Though support for such a process should be added and would also be handled here. * @method module:WidgetComponents.ActionTableController#loadData */ $scope.loadData = function() { var request; clearFault(); switch($scope.options.data_source) { case \"ajax\": request = new SPGlideAjax($scope.options.script); request.addParam(\"sysparm_name\", $scope.options.script_method); request.addParam(\"query\", $scope.options.query); request.getXMLAnswer($scope.receiveData); break; case \"snapi\": if($scope.options.endpoint) { if($scope.options.endpoint[0] !== \"/\") { $scope.options.endpoint = \"/\" + $scope.options.endpoint; } $http.get($scope.options.endpoint + \"?query=\" + $scope.options.query) .then(function(response) { if(response.status === 200) { $scope.receiveData(response.data.result); } else { fault(new Error(\"Malformed request for endpoint data - HTTP\" + response.status + \": \" + response.statusText)); } }, fault); } else { fault(new Error(\"No 'endpoint' option is defined\")); } break; case \"server\": case \"table\": $scope.prepareData(); break; default: console.error(\"Unknown Data Source (data_source) option specified for STSTable widget[\" + $scope.options.id + \"]: \", $scope); $scope.error = { \"message\": \"Unknown Data Source (data_source) option specified for widget.\", \"options\": $scope.options }; } }; /** * Called for receiving the text portion of a request for data. All text is assumed to be a JSON * object with the general format: * ``` * { * \"rows\": [{ * Object 1 Data... * }, { * Object 2 Data... * }, { * ... * {, * Object N Data... * }] * } * ``` * * An object is used to allow for other information to be present on the API call for use later. * @method module:WidgetComponents.ActionTableController#receiveData * @param {String} response */ $scope.receiveData = function(response) { var loading; if(response) { if(typeof(response) === \"string\") { try { loading = JSON.parse(response); } catch(parseException) { fault(parseException); } } else { loading = response; } if(loading &amp;&amp; loading.rows instanceof Array) { $scope.data.rows.splice(0); $scope.data.rows.push.apply($scope.data.rows, loading.rows); $scope.data.loaded = Date.now(); $scope.prepareData(); } else { fault(new Error(\"Receive malformed data, must return a Object JSON with a \\\"rows\\\" property that contains the array to load\")); } } else { fault(new Error(\"Failed to receive any data\")); } }; /** * Essentially prepares the data received from the server. * * This primarily involves setting the `$search` property for easy lower cased * string index checks for filtering based on the columns and `options.filterable`. * * Additionally, the data objectis emitted on the root scope for other widgets to * consume if needed under the event \"ststable:data:[ID]\" where \"[ID]\" is the table's * ID specified in options. This allows another widget on the same page as the table * to implement something akin to `$scope.$on(\"ststable:data:[ID]\", $scope.processAPIData)` * to receive the data and perform any needed actions. * @method module:WidgetComponents.ActionTableController#prepareData */ $scope.prepareData = function() { var column, load, row, c, i; if($scope.data.rows) { for(i=0; i&lt;$scope.data.rows.length; i++) { row = $scope.data.rows[i]; row.$search = \"\"; // Ensure that the visible columns are searchable if($scope.options.filterable &amp;&amp; $scope.options.filterable.length) { // Add additional columns that are flagged as filterable in the instance options load = $scope.columns.concat($scope.options.filterable); } else { load = $scope.columns; } for(c=0; c&lt;load.length; c++) { column = load[c]; if(typeof(row[column.field]) === \"string\") { // Map to lower case; Filter is meant to be case insensitive row.$search += \" :: \" + row[column.field].toLowerCase(); } else if(typeof(row[column.field]) === \"object\") { // Handle Field Descriptor data if(row[column.field].display) { row.$search += \" :: \" + row[column.field].display.toLowerCase(); } } else { // Direct Value row.$search += \" :: \" + row[column.field]; } } } $scope.corpus.sort(sortData); } mapDataFields(); $scope.$root.$emit(\"ststable:data:\" + $scope.options.id, $scope.data); $scope.loadCorpus(); }; /** * Filter and sort the general data received from the server. * * This serves as our cache for paging through the data set. * @method module:WidgetComponents.ActionTableController#loadCorpus */ $scope.loadCorpus = function() { $scope.corpus.splice(0); $scope.pages.splice(0); var row, i; if($scope.data.rows) { for(i=0; i&lt;$scope.data.rows.length; i++) { row = $scope.data.rows[i]; if(visible(row)) { $scope.corpus.push(row); } } $scope.corpus.sort(sortData); } $scope.pageCount = $scope.corpus.length/$scope.state.size; for(i=0; i&lt;$scope.pageCount; i++) { $scope.pages.push(i + 1); } $scope.loadRender(); }; /** * Load data from the `corpus` to the `render` array for the current page being viewed. * @method module:WidgetComponents.ActionTableController#loadRender */ $scope.loadRender = function() { $scope.render.splice(0); var start = $scope.state.page * $scope.state.size, end = start + $scope.state.size, row, i; for(i=start; i&lt;end &amp;&amp; i&lt;$scope.corpus.length; i++) { row = $scope.corpus[i]; if(row) { $scope.render.push(row); } } $scope.update(); }; /** * Sets the page and updates the `render` array for display via the `loadRender` method. * @method module:WidgetComponents.ActionTableController#toPage * @param {Number} page */ $scope.toPage = function(page) { $scope.state.page = page - 1; $scope.loadRender(); saveState(); }; /** * * @method module:WidgetComponents.ActionTableController#getPageClasses * @param {Number} page * @returns {String} */ $scope.getPageClasses = function(page) { if(page -1 === $scope.state.page) { return \"btn-primary\"; } else { return \"btn-default\"; } }; /** * Check if an action is visible based on its `condition` object. * * No condition object indicates it is always visible. * * Condition checking is managed with the `checkConditions` function. * @method module:WidgetComponents.ActionTableController#actionVisible * @param {Object} row * @param {Object} action * @return {Boolean} */ $scope.actionVisible = function(row, action) { if(action.condition) { return $scope.checkCondition(row, action.condition); } return true; }; /** * Process an action object for a row. * @method module:WidgetComponents.ActionTableController#processAction * @param {Object} row * @param {Object} action */ $scope.processAction = function(row, process) { var buffer, keys, i; switch(process.action) { case \"link\": buffer = $scope.completeTemplate(row, process.perform); if(buffer[0] !== \"/\") { buffer = \"/\" + buffer; } location = buffer; break; case \"newlink\": buffer = $scope.completeTemplate(row, process.perform); if(buffer[0] !== \"/\") { buffer = \"/\" + buffer; } window.open(buffer, \"_blank\"); break; case \"form-modal\": process = fillin(process, row); console.log(\"FilledIn: \", process); spModal.open({ \"shared\": $scope.state, \"value\": process, \"title\": process.title, \"widget\": \"widget-form\", \"widgetInput\": process }).then(function (/* button */) { // User clicked \"OK\" - example; button = {\"label\":\"OK\",\"primary\":true,\"focus\":true} }, function(/* error */) { // User clicked \"Cancel\", The close button on the dialog, or clicked outside the box }); break; case \"ajax-call\": process = fillin(process, row); keys = Object.keys(process); buffer = new SPGlideAjax(process.ajax_class); buffer.addParam(\"sysparm_name\", process.ajax_method); for(i=0; i&lt;keys.length; i++) { buffer.addParam(keys[i], process[keys[i]]); } buffer.getXMLAnswer(function(/* response */) { if(process.new_url &amp;&amp; process.new_url[0] !== \"/\") { process.new_url = \"/\" + process.new_url; } switch(process.ajax_complete) { case \"redirect\": location = process.new_url; break; case \"newwindow\": window.open(process.new_url, \"_blank\"); break; } }); break; } }; /** * Get the string to display for the value in row under the column's field value. * @method module:WidgetComponents.ActionTableController#renderValue * @param {Object} row Of data from which to get the value to render. * @param {Object} column Describing what data should be rendered. * @return {String} To place in the table */ $scope.renderValue = function(row, column) { var point = row[column.field], formatting, buffer, value; buffer = typeof(point); if(buffer === \"object\") { formatting = point.type || column.formatting || buffer; value = point.display; } else { formatting = column.formatting || buffer; value = point; } switch(formatting) { case \"time\": buffer = new Date(value); return buffer.toLocaleDateString() + \" \" + buffer.toLocaleTimeString(); case \"date\": buffer = new Date(value); return buffer.toLocaleDateString(); } // Contain runaway decimal point values if(typeof(value) === \"number\" &amp;&amp; value%1) { value = value.toFixed(3); } return value; }; /** * Using a Modal, show the status text for the row. * @method module:WidgetComponents.ActionTableController#viewStatusWarning * @param {Object} row */ $scope.viewStatusWarning = function(row) { spModal.confirm(row.$status_text); }; /** * Performs basic token replacement in a string based on the values in the row object using \"{{...}}\" for replacement * indicators. * * Due to service-now template processing, using \"${...}\" fails without oerly complicated syntax, for example * an option value of \"My name is ${name}\" simply displays as \"My name is name\" and looking at the option value * received to the widget, the value of that option will also be \"My name is name\" because Sevice-Now's templating * has already altered the value. * * Additionally note that the replacement handling is managed with cached regular expressions generated at the start * of this controller. * @method module:WidgetComponents.ActionTableController#completeTemplate * @param {Object} row * @param {String} template * @returns {String} */ $scope.completeTemplate = function(row, template) { for(var i=0; i&lt;fieldList.length; i++) { template = template.replace(fieldTracking[fieldList[i]], row[fieldList[i]] || \"\"); } return template; }; /** * Every field in the condition that is defined must match the corresponding field value in the row, or the * check fails. * @method module:WidgetComponents.ActionTableController#checkCondition * @param {Object} row * @param {Object} condition * @returns {Boolean} */ $scope.checkCondition = function(row, condition) { for(var i=0; i&lt;fieldList.length; i++) { if(condition[fieldList[i]] !== undefined &amp;&amp; condition[fieldList[i]] !== row[fieldList[i]] &amp;&amp; (!row[fieldList[i]] || row[fieldList[i]].value !== condition[fieldList[i]])) { return false; } } return true; }; /** * Get a new array of data from the server and apply it to the current state and render. * @method module:WidgetComponents.ActionTableController#reloadData */ $scope.reloadData = function() { var success, failure; if($scope.options.data_source == \"ajax\") { $scope.loadData(); } else { success = function(response) { $scope.data.rows.splice(0); $scope.data.rows.push.apply($scope.data.rows, response.data.rows); $scope.data.loaded = response.data.loaded; $scope.loadData(); endReload(); }; failure = function(error) { $scope.error = error; endReload(); }; $scope.reloadIcon = \"fa-refresh fa-spin\"; $scope.update(); $scope.server.get() .then(success, failure); } }; /** * * @method module:WidgetComponents.ActionTableController#getLastUpdateDisplay * @returns {String} 0 */ $scope.getLastUpdateDisplay = function() { var date = new Date($scope.data.loaded); return date.toLocaleDateString() + \" \" + date.toLocaleTimeString(); }; /** * Forces a re-rendering of AngularJS bindings * @method module:WidgetComponents.ActionTableController#update */ $scope.update = function() { try { $scope.$digest(); } catch(updateException) { // Generally just a digest exception from a current update cycle } }; // Initialize Corpus for rendering based on the loaded state if(!isNaN($scope.options.refresh_interval) &amp;&amp; $scope.options.refresh_interval) { setTimeout(refresh, $scope.options.refresh_interval); } $scope.loadData(); setIcons(); }; × Search results Close "},"providers_spglideajax.js.html":{"id":"providers_spglideajax.js.html","title":"Source: providers/spglideajax.js","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Source: providers/spglideajax.js function SPGlideAjax($http) { /** @module AngularProviders */ /** * A simplified version of GlideAJAX for use within the Service Portal. * * This specifically implements getAnswer and getXMLAnswer with some modernization * for Promise support through Angular's $http service. * @class module:AngularProviders.SPGlideAjax * @param {$http} $http * @example * // Script Include * var Example = Class.create(); * Example.prototype = Object.extendsObject(AbstractAjaxProcessor, { * \"type\": \"Example\", * \"functionA\": function() { * return this.getParameter(\"a\"); * } * }); * * // Client Script * function _controller($scope, SPGlideAjax) { * var ga = new SPGlideAjax(\"Example\"); * ga.addParam(\"sysparm_name\", \"functionA\"); * ga.addParam(\"a\", 9); * // (This will print \"9\" as a warning to the browser's console) * ga.getXMLAnswer(console.warn); *} */ /** * Static space reference for quick replacement. * @type {RegExp} * @memberof module:AngularProviders.SPGlideAjax * @instance * @private */ var regexSpace = / /g; /** * Service-Now's GlideAjax works with form data strings instead of JSON, * so this is used to convert the parameters to the appropriate format. * @method module:AngularProviders.SPGlideAjax#serializeToForm * @priavte * @param {Object} data The object to parse into form data. The values off the object * should be easily represented as strings or issues may occur. * @return {String} Form data string of the data in the passed object */ var serializeToForm = function(data) { var keys = Object.keys(data), encoding = [], x; for (x = 0; x &lt; keys.length; x++) { encoding.push(encodeURIComponent(keys[x]) + \"=\" + encodeURIComponent(data[keys[x]] ? data[keys[x]].toString() : \"\")); } return encoding.join(\"&amp;\").replace(regexSpace, \"+\"); }; /** * General options to use with all $HTTP calls * @type {Object} * @memberof module:AngularProviders.SPGlideAjax * @instance * @private */ var generalOptions = { \"headers\": { \"content-type\": \"application/x-www-form-urlencoded; charset=utf-8\" } }; // The actual class constructor returned by the Factory declaration in Angular return function(processor) { var factory = this, parameters = {}; parameters.sysparm_processor = processor; parameters.sysparm_scope = \"global\"; parameters.sysparm_want_session_messages = \"true\"; /** * Uses the parameters object to handle processing. * * If the sysparm_name property is missing, a warning is sent to the * console for developer awareness. * @method module:AngularProviders.SPGlideAjax#getAnswer * @param {Function} callback Takes callback(answer, error) and resolves appropriately * the same as the returned promise. * @return {Promise} The promise resolves with the answer XML element on * success or an Error object on failure. */ this.getAnswer = function(callback) { if (!parameters.sysparm_name) { console.warn(\"GlideAJAX call with no sysparm_name defined; Call addParam('sysparm_name', '[ScriptInclude Method Name]') prior to calling getXMLAnswer\"); } return $http.post(\"/xmlhttp.do\", serializeToForm(parameters), generalOptions) .then(function(response) { var el = $(response.data), answer; if (el &amp;&amp; el.length &gt;= 2 &amp;&amp; el[1].getAttribute) { answer = el[1]; if (callback) { callback(answer); } return answer; } else { if (callback) { callback(null); } return null; } }); }; /** * Sets a parameter for a pending AJAX request. * @method module:AngularProviders.SPGlideAjax#addParam * @param {String} field The name of the field to be passed. * @param {String} value The value to be passed for that field. */ this.addParam = function(field, value) { parameters[field] = value; }; /** * Get the answer property from the returned XML. * @method module:AngularProviders.SPGlideAjax#getXMLAnswer * @param {Function} callback Takes callback(answer, error) and resolves appropriately * the same as the returned promise. * @return {Promise} Resolves on success with the answer string and on failure * throws to the catch chain. */ this.getXMLAnswer = function(callback) { return factory.getAnswer() .then(function(answer) { if (answer &amp;&amp; answer.getAttribute) { answer = answer.getAttribute(\"answer\"); } else { answer = null; } if (!answer) { answer = null; } if (callback) { callback(answer); } }, callback); }; }; } × Search results Close "},"scripts_include.js.html":{"id":"scripts_include.js.html","title":"Source: scripts/include.js","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Source: scripts/include.js /** @module ScriptIncludes */ var ActionTableScriptAPI = Class.create(); /** * Contains assistive methods for working with the ActionTable widget and acts as * an anchor point for leveraging server-side data with script includes while not * using the SPGlideAJAX functionality. * * Note that ActionTable supports pulling data from a client callable script include * as well as leveraging the REST API (Though authentication may pose issues with REST). * * Extending this class instead of AbstractAjaxProcessor is not necessary from a * functionality perspective, but does help to track or imply why that script * exists. * @class module:ScriptIncludes.ActionTableScriptAPI */ ActionTableScriptAPI.prototype = Object.extendsObject(AbstractAjaxProcessor, { \"type\": \"ActionTableScriptAPI\", \"getFieldDescription\": ActionTableScriptAPI.getFieldDescription, \"finishQuery\": ActionTableScriptAPI.finishQuery, \"toJSON\": ActionTableScriptAPI.toJSON }); /** * Takes a general query and flushes out the record data with field descriptors. * @method module:ScriptIncludes.ActionTableScriptAPI#finishQuery * @static * @param {GlideRecord} queried That has the search parameters entered and `query()` * has been called. * @return {Array} With */ ActionTableScriptAPI.finishQuery = function(queried) { var result = [], build, keys, key, i; if(queried.next()) { keys = Object.keys(queried); do { build = {}; for(i=0; i&lt;keys.length; i++) { key = keys[i]; build[key] = ActionTableScriptAPI.getFieldDescription(queried, key); } result.push(build); } while(queried.next()); } return result; }; /** * Retrieve the value for the field along with additional descriptive information about the field * in an object to add to the row data. * * This does create somewhat of a duplication of data as this extra data will be the same across * several rows. * @method module:ScriptIncludes.ActionTableScriptAPI#getFieldDescription * @static * @param {GlideRecord} record * @param {String} name * @returns {Object} With properties; display_value, value, type, label */ ActionTableScriptAPI.getFieldDescription = function(record, name) { var element = record.getElement(name), field = {}; field.display_value = record.getDisplayValue(name); field.value = record.getValue(name); if(record) { field.type = element.getED().getInternalType(); field.label = element.getLabel(); } field.display = field.display_value; field.descriptive = true; return field; }; /** * Convert a GlideRecord's data to JSON. * * This method does _NOT_ use `getFieldDescription` as that isn't the expected mode for * the ActionTable widget. If looking for more flushed out data, use the `finishQuery` * method instead. * @method module:ScriptIncludes.ActionTableScriptAPI#toJSON * @static * @param {GlideRecord} record * @return {Object} */ ActionTableScriptAPI.toJSON = function (record, raw) { raw = raw || {}; var keys = Object.keys(record), json = {}, i; json.$search = \"\"; if (typeof (record.getValue) === \"function\") { for (i = 0; i &lt; keys.length; i++) { json[keys[i]] = raw[keys[i]] ? record.getValue(keys[i]) : record.getDisplayValue(keys[i]); } } else { for (i = 0; i &lt; keys.length; i++) { json[keys[i]] = record[keys[i]]; } } return json; }; /** * Pull general data from a table. * @method module:ScriptIncludes.ActionTableScriptAPI#getTableData * @param {String} table To query * @param {String} query Encoded Query to pass into the query. * @param {Number} [page_size] Optional limiter for number of rows to retrieve. * @param {Number} [page] Optional offset for getting a specific page of data. * @return {Array} Of records. */ ActionTableScriptAPI.prototype.getTableData = ActionTableScriptAPI.getTableData = function (table, query, page_size, page) { var search = new GlideRecord(table), offset = page * page_size, result = [], i; search.addEncodedQuery(query); search.query(); if (search.hasNext()) { for (i = 0; i &lt; offset; i++) { search.next(); } while (search.next()) { result.push(ActionTableScriptAPI.toJSON(search)); } } return result; }; /** * Returns non-persistent random data; If a page is requested twice, the data will not be the same. * * Uses page_size to gauge the amount of data to generate. * @method module:ScriptIncludes.ActionTableScriptAPI#generateExampleData * @static * @param {String} filter * @param {Number} page_size Defaults to 30 * @return {Array} Length either 5 * page_size or 30 of semi-random. */ ActionTableScriptAPI.generateExampleData = function (filter, page_size) { var result = [], amount; if(page_size) { amount = page_size * 10; } else { amount = 30; } for (var i = 0; i &lt; amount; i++) { result.push(ActionTableScriptAPI.toJSON({ \"name\": \"Name Test \" + i, \"short_description\": \"Short Description \" + i, \"sys_id\": \"abcd_\" + i, \"state\": Math.random() &lt; .3 ? \"inactive\" : \"active\" })); } return result; }; /** * Returns non-persistent random data; If a page is requested twice, the data will not be the same. * * Uses page_size to gauge the amount of data to generate. * @method module:ScriptIncludes.ActionTableScriptAPI#getExampleData * @param {String} filter * @param {Number} page_size Defaults to 30 * @return {Array} Length either 5 * page_size or 30 of semi-random. */ ActionTableScriptAPI.prototype.getExampleData = function(filter, page_size) { page_size = page_size || this.getParameter(\"page_size\"); filter = filter || this.getParameter(\"filter\"); return JSON.stringify({ \"rows\": ActionTableScriptAPI.generateExampleData(filter, page_size) }); }; × Search results Close "},"widget_specifications.js.html":{"id":"widget_specifications.js.html","title":"Source: widget/specifications.js","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Source: widget/specifications.js /** * Collection of classes that merely describe data used in the Widget. * @module Specifications */ × Search results Close "},"widget_server.js.html":{"id":"widget_server.js.html","title":"Source: widget/server.js","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Source: widget/server.js /** @module WidgetComponents */ /** * The Angular controller for managing the Action Table * @class module:WidgetComponents.ActionTableServerScript */ /** * Object created by Service-Now and passed to the Widget controller on initialization. * @memberof module:WidgetComponents.ActionTableServerScript * @typedef {Object} data * @property {Number} loaded Timestamp for when the data was retrieved * @property {Array} rows Contains the row data for the table * @property {String} error Message from an error while building the data for the table */ /** * Object created by Service-Now and passed to the Widget controller on initialization. * @memberof module:WidgetComponents.ActionTableServerScript * @typedef {Object} options * @property {String} filterable Comma seperated list of fields that should be added * to the $search property of objects for easy filtering. * @property {Number} per_page Forces the table to show a set number of rows per page * of data and hides the per_page selector on the table. * @property {Number} refresh_interval Milliseconds to wait between pulling data * from the server again. * @property {String} data_source Indicating where/how to retrieve data. */ (function() { var buffer, i; data.loaded = Date.now(); // Level Set Options if(options.refresh_interval) { options.refresh_interval = parseInt(options.refresh_interval); if(isNaN(options.refresh_interval) || options.refresh_interval &lt; 60000) { options.refresh_interval = 60000; } } if(options.filterable) { options.filterable = options.filterable.split(\",\"); for(i=0; i&lt;options.filterable.length; i++) { options.filterable[i] = options.filterable[i].trim(); } } else { options.filterable = []; } if(options.per_page) { options.per_page = parseInt(options.per_page); } // Retrieve rows based on options try { switch(options.data_source) { case \"table\": data.rows = STSTableScriptAPI.getTableData(options.table, options.query); break; case \"server\": if(typeof(STSTableScriptAPI[options.script_method]) == \"function\") { data.rows = STSTableScriptAPI[options.script_method](options.query); } else { buffer = \"Action Table: Script Method \\\"\" + options.script_method + \"\\\" does not exist for Script STSTableScriptAPI\"; gs.error(buffer); throw new Error(buffer); } break; case \"snapi\": case \"ajax\": // Handled Client Side data.rows = []; break; default: gs.error(\"Action Table: Unknown Data Source: \" + options.data_source); } } catch(sourceException) { data.error = sourceException.message || \"Generic Error occurred\"; gs.error(sourceException); } })(); × Search results Close "},"widget_action.js.html":{"id":"widget_action.js.html","title":"Source: widget/action.js","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Source: widget/action.js /** * Describes options to present to the user on the table to take an * action on a specific row. * * This exists only for documentation purposes and is not actually * defined in the instance. * @memberof Specifications */ class Action { constructor() { /** * With classes specifically for rendering an icon. This will generally follow font-awesome 4.7 or another glyph set included on your portal * @type {String} */ this.icon; /** * For the displayed text * @type {String} */ this.label; /** * Used for hover text (HTML title property) on the button * @type {String} */ this.title; /** * Indicating how interactions with this action should process. * * Specific actions that are available: * + `link` or `newlink` go to a URL. `newlink` doing so in a new window or tab * + `form-modal` opens a modal on the page with a form view. Every key's value * is filled in for the object passed to the modal. This action also uses several * specific extra key values; `table`, `sys_id`, and `view` to specify the form to * open. These values are template completed before being invoked. * + `ajax-call` makes an AJAX call similar to a GlideAjax call. This action also fills * out the key values for all keys on the object and then passes each key as a parameter * in the AJAX call. The `tbl_class` is used to initialize the SPGlideAjax instance and * `tbl_method` is specifically added as the `\"sysparm_name\"` parameter of the AJAX call. * Both keys can also be specified specifically as a key:value pair on the row's data that * can be completed for a more dynamic AJAX call. Additionally, a `tbl_complete` key is used * for a switch case that can be either `redirect` or `newwindow` and will use the `new_url` * key to open or redirect once a response is received. However, as a note, deeply nested * data will NOT get replacements. * @type {String} */ this.action; /** * Optional object describing values that have to match for the action to display * @type {Object} */ this.condition; /** * Only for the `link` or `newlink` action, this specifies the URL. Template tokens here * are replaced by the data rows' values. * @type {String} */ this.perform; /** * Only for the `form-modal` action. Specifies the table against which the form should open. * @type {String} */ this.table; /** * Only for the `form-modal` action. Specifies the sys_id of the record to open in the form. * @type {String} */ this.sys_id; /** * Only for the `form-modal` action. Specifies the view to use for the record in the modal. * @type {String} */ this.view; /** * Only for the `ajax-call` action. Specifies the class on which to initialize the GlideAjax. * @type {String} */ this.ajax_class; /** * Only for the `ajax-call` action. Specifies the method to invoke on the Script Include. * @type {String} */ this.ajax_method; /** * Only for the `ajax-call` action. Optional specification of an action to take once the call is * complete. * * Possible values: * + `redirect` * + `newwindow` * @type {String} */ this.ajax_complete; } } × Search results Close "},"widget_column.js.html":{"id":"widget_column.js.html","title":"Source: widget/column.js","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Source: widget/column.js /** * Describes a field from a row data object to render on the table. * * This exists only for documentation purposes and is not actually * defined in the instance. * @memberof Specifications */ class Column { constructor() { /** * Displayed essentially as the header for this column on * the table. * @type {String} */ this.label; /** * To pull the data from on the row data object. * @type {String} */ this.field; } } × Search results Close "},"widget_state.js.html":{"id":"widget_state.js.html","title":"Source: widget/state.js","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Source: widget/state.js /** * Important stateful data for the Widget. * * This exists only for documentation purposes and is not actually * defined in the instance. * @memberof Specifications */ class State { constructor() { /** * Used for filtering a row based on * the values within it. * @type String */ this.search; /** * The current page of the table being rendered. * @type Number */ this.page; /** * The number of rows to display per page. * of the `state.size` value is copied here used for user control of the * paging size. This is later in a $watch statement to handle keeping * size straight when changed this way. * * Direct modifications to `state.size` after the widget has been created * will NOT currently be reflected back to this value. * @type Number */ this.size; /** * Names the column by which to sort rows * using the field value of the column. * * If the field does not exist, no ordering is explicitly performed * @type Number */ this.order; /** * Controls the sort ordering and is returned * when `a` is considered to precede `b`. * @type Number */ this.above; /** * Controls the sort ordering and is returned * when `a` is considered to procede `b`. * @type Number */ this.below; } } × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Modules Classes SPGlideAjax ActionTableScriptAPI ActionTableController ActionTableServerScript Action Column State × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Classes Classes SPGlideAjax ActionTableScriptAPI ActionTableController ActionTableServerScript Action Column State × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Action Table A configurable table widget designed to pull data from scripts or tables and provide an instance option way to configure conditional buttons for each row. GitHub Repository: https://github.com/alexanderson-sedgwick/action-table Documentation: https://alexanderson-sedgwick.github.io/action-table/ Quick Setup The easiest way to setup data for the table while keeping your update set contained is with a client callable script include. Create the Script Include In your instance start a new Script Include ( /sys_script_include.do?sys_id=-1 ) Enable \"Client Callable\" Setup the method that will return the data to return a JSON string of the array Setup any methods you wish to be called from buttons on the table (if any) Configure the Widget Instance Set the Data source as \"Client Callable Script\" For \"Client Script to Call\" enter the name of the script you created For \"Script Method for Data\" enter the name of the method from the script that returns the data For \"Columns JSON\" enter a JSON array of objects describing a \"label\" and a \"field\". The label is displayed in the header and the field is the field from the returned data objects to be displayed in the cell. As an example; [ { \"label\": \"Name\", \"field\": \"name\" }, { \"label\": \"Short Description\", \"field\": \"short_description\" } ] For the \"Actions JSON\" enter JSON describing the action that can be provided to a row. These may have simple conditions mapping a field name to a specific value where the action is only visible when all parts of the condition object match. As an example; [ { \"label\": \"Activate {{name}}\", \"field\": \"name\", \"action\": \"link\", \"title\": \"Activate {{name}}\", \"classes\": \"btn btn-success\", \"perform\": \"/incident.do?sys_id=-1&amp;test={{sys_id}}\", \"condition\": { \"state\": \"inactive\" } }, { \"label\": \"Deactivate {{name}}\", \"field\": \"name\", \"action\": \"link\", \"title\": \"Deactivate {{name}}\", \"classes\": \"btn btn-warning\", \"perform\": \"/incident.do?sys_id=-1&amp;test={{sys_id}}\", \"condition\": { \"state\": \"active\" } } ] Fill out any other options as desired (See their help text). They are not required. Additional Actions The action object has a few set fields that the widget uses to display the data and each action has additional fields that it uses. Each field that's used is usually updated with template replacements, thus in the above examples, {{name}} is replaced with the name field from the object for that row, and the {{sys_id}} value for the url allows creaiton of specific links. Each object has a few key values specific to rendering the button: icon With classes specifically for rendering an icon. This will generally follow font-awesome 4.7 or another glyph set included on your portal label For the displayed text title Used for hover text (HTML title property) on the button condition Optional object describing values that have to match for the action to display action Indicating how interactions with this action should process. The action field describes what kind of action is taken when the button is pressed and has a few options: link or newlink go to a URL. newlink doing so in a new window or tab. Example: { \"label\": \"Activate {{name}}\", \"action\": \"link\", \"title\": \"Activate {{name}}\", \"classes\": \"btn btn-success\", \"perform\": \"/incident.do?sys_id=-1&amp;test={{sys_id}}\", \"condition\": { \"state\": \"inactive\" } } form-modal opens a modal on the page with a form view. Every key's value is filled in for the object passed to the modal. This action also uses several specific extra key values; table, sys_id, and view to specify the form to open. These values are template completed before being invoked. Example: { \"label\": \"\", \"title\": \"{{name}}\", \"action\": \"form-modal\", \"classes\": \"btn btn-primary\", \"icon\": \"fa fa-info-circle\", \"table\": \"sys_user\", \"sys_id\": \"{{sys_id}}\", \"view\": \"default\" } ajax-call makes an AJAX call similar to a GlideAjax call. This action also fills out the key values for all keys on the object and then passes each key as a parameter in the AJAX call. The ajax_class is used to initialize the SPGlideAjax instance and ajax_method is specifically added as the \"sysparm_name\" parameter of the AJAX call. Both keys can also be specified specifically as a key:value pair on the row's data that can be completed for a more dynamic AJAX call. Additionally, a ajax_complete key is used for a switch case that can be either redirect or newwindow and will use the new_url key to open or redirect once a response is received. However, as a note, deeply nested data will NOT get replacements. Example: { \"label\": \"Call AJAX\", \"title\": \"Activate {{name}}\", \"classes\": \"btn btn-success\", \"action\": \"ajax\", \"ajax_method\": \"ClientCallableScript\", \"ajax_method\": \"ScriptFunction\", \"some_data_for_the_function\": \"{{sys_id}}\", \"quick_note\": { \"this_will_NOT_be_replaced\": \"{{name}}\" } } × Search results Close "},"module-WidgetComponents.ActionTableController.html":{"id":"module-WidgetComponents.ActionTableController.html","title":"Class: ActionTableController","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Class: ActionTableController WidgetComponents. ActionTableController new ActionTableController() The Angular controller for managing the Action Table Source: widget/client.js, line 2 Members corpus :Array Each element contained here is an element that is valid after the rows have been filtered by search and sort criteria. Type: Array Source: widget/client.js, line 277 error :Object Handles displaying an error to the widget. Generally set by calling the private function fault. Type: Object Source: widget/client.js, line 253 filterIcon :String The displayed icon in the filter to give feedback to the user. Type: String Source: widget/client.js, line 262 pages :Array Doubles as a page count and rendering array for ng-repeat. Type: Array Source: widget/client.js, line 294 reloadIcon :String The displayed icon for reloading data to give feedback to the user. Type: String Source: widget/client.js, line 269 render :Array Each element contained here is a row to render on the page. This is pared down to only the rows that should render based on the current page and sourced from the corpus array to follow search and sort criteria and drive a faster rendering. Type: Array Source: widget/client.js, line 287 state :State Holds the stateful data for the widget that should be tracked and reloaded on refresh. This is specifically accomplished by calls to saveState in combination with a $watch specification. Type: State Source: widget/client.js, line 308 Methods actionVisible(row, action) Check if an action is visible based on its condition object. No condition object indicates it is always visible. Condition checking is managed with the checkConditions function. Parameters: Name Type Description row Object action Object Source: widget/client.js, line 612 Returns: Type Boolean checkCondition(row, condition) Every field in the condition that is defined must match the corresponding field value in the row, or the check fails. Parameters: Name Type Description row Object condition Object Source: widget/client.js, line 765 Returns: Type Boolean &lt;private&gt; clearFault() Internal method for clearing an error that had been encountered if one such error exists. Source: widget/client.js, line 186 completeTemplate(row, template) Performs basic token replacement in a string based on the values in the row object using \"{{...}}\" for replacement indicators. Due to service-now template processing, using \"${...}\" fails without oerly complicated syntax, for example an option value of \"My name is ${name}\" simply displays as \"My name is name\" and looking at the option value received to the widget, the value of that option will also be \"My name is name\" because Sevice-Now's templating has already altered the value. Additionally note that the replacement handling is managed with cached regular expressions generated at the start of this controller. Parameters: Name Type Description row Object template String Source: widget/client.js, line 742 Returns: Type String &lt;private&gt; endReload() Waits 1 second to reset the reload icon to give the visual impact time. Source: widget/client.js, line 138 &lt;private&gt; fault(error) Internal method for displaying an error that was encountered. Parameters: Name Type Description error Error That occurred and should be displayed Source: widget/client.js, line 167 fillin(fill, row) Use template filling to create a new object whose values mimic the fill object but with templates completed based on the row. Due to the regular expressions in volved and the number of search/replacements that can be triggered here, this method should be used sparingly. Parameters: Name Type Description fill Object Object whose values are to be completed row Object Source for values Source: widget/client.js, line 149 &lt;private&gt; filtering() Timed function used to balance user typing with when to fire updating the results. Source: widget/client.js, line 107 getLastUpdateDisplay() Source: widget/client.js, line 813 Returns: 0 Type String getPageClasses(page) Parameters: Name Type Description page Number Source: widget/client.js, line 598 Returns: Type String loadCorpus() Filter and sort the general data received from the server. This serves as our cache for paging through the data set. Source: widget/client.js, line 535 loadData() Retrieves data from the server if necessary. This is essesntially a stepping method for AJAX sourced data as the other 2 sources (server script, and table) would already be populated here by the server initialization. The SPGlideAjax is heavily favored for the ability to create new configurable data sources without modifying the widget or its supporting pieces while also keeping the creating of the data in a more traditionally understood form, Script Includes, instead of passing the data through a more web traditional method such as an API, where Scripted APIs may get heavier. Though support for such a process should be added and would also be handled here. Source: widget/client.js, line 378 loadRender() Load data from the corpus to the render array for the current page being viewed. Source: widget/client.js, line 565 mapDataFields() Updates the fieldTracking &amp; fieldList properties. Source: widget/client.js, line 197 mapFields(row) Checks the object keys to ensure that all fields have a RegExp mapping in the fieldTracking object. Parameters: Name Type Description row Object Source: widget/client.js, line 213 prepareData() Essentially prepares the data received from the server. This primarily involves setting the $search property for easy lower cased string index checks for filtering based on the columns and options.filterable. Additionally, the data objectis emitted on the root scope for other widgets to consume if needed under the event \"ststable:data:[ID]\" where \"[ID]\" is the table's ID specified in options. This allows another widget on the same page as the table to implement something akin to $scope.$on(\"ststable:data:[ID]\", $scope.processAPIData) to receive the data and perform any needed actions. Source: widget/client.js, line 479 processAction(row, action) Process an action object for a row. Parameters: Name Type Description row Object action Object Source: widget/client.js, line 630 receiveData(response) Called for receiving the text portion of a request for data. All text is assumed to be a JSON object with the general format: { \"rows\": [{ Object 1 Data... }, { Object 2 Data... }, { ... {, Object N Data... }] } An object is used to allow for other information to be present on the API call for use later. Parameters: Name Type Description response String Source: widget/client.js, line 432 &lt;private&gt; refresh() Used to keep the data up to date if a refresh interval has been specified. Source: widget/client.js, line 127 reloadData() Get a new array of data from the server and apply it to the current state and render. Source: widget/client.js, line 782 renderValue(row, column) Get the string to display for the value in row under the column's field value. Parameters: Name Type Description row Object Of data from which to get the value to render. column Object Describing what data should be rendered. Source: widget/client.js, line 696 Returns: To place in the table Type String reorder(column) Change the direction of sorting or the column to sort by. Calling on the currently sorted column toggles the sort direction. Changing to a new column does NOT change the sort direction. Parameters: Name Type Description column Column Source: widget/client.js, line 355 &lt;private&gt; saveState() Save an encoded value of the scope's state value to give persistence to the table's rendering. Source: widget/client.js, line 43 setIcons() Updates the icons for various objects for cached rendering purposes Source: widget/client.js, line 52 sortData(a, b) Sorting function used to sort the data.rows array based on the current state values. Parameters: Name Type Description a b Source: widget/client.js, line 75 toPage(page) Sets the page and updates the render array for display via the loadRender method. Parameters: Name Type Description page Number Source: widget/client.js, line 587 update() Forces a re-rendering of AngularJS bindings Source: widget/client.js, line 823 viewStatusWarning(row) Using a Modal, show the status text for the row. Parameters: Name Type Description row Object Source: widget/client.js, line 733 visible(row) Parameters: Name Type Description row Object Source: widget/client.js, line 99 × Search results Close "},"module-AngularProviders.html":{"id":"module-AngularProviders.html","title":"Module: AngularProviders","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Module: AngularProviders Source: providers/spglideajax.js, line 2 Classes SPGlideAjax × Search results Close "},"module-AngularProviders.SPGlideAjax.html":{"id":"module-AngularProviders.SPGlideAjax.html","title":"Class: SPGlideAjax","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Class: SPGlideAjax AngularProviders. SPGlideAjax new SPGlideAjax($http) A simplified version of GlideAJAX for use within the Service Portal. This specifically implements getAnswer and getXMLAnswer with some modernization for Promise support through Angular's $http service. Parameters: Name Type Description $http $http Source: providers/spglideajax.js, line 4 Example // Script Include var Example = Class.create(); Example.prototype = Object.extendsObject(AbstractAjaxProcessor, { \"type\": \"Example\", \"functionA\": function() { return this.getParameter(\"a\"); } }); // Client Script function _controller($scope, SPGlideAjax) { var ga = new SPGlideAjax(\"Example\"); ga.addParam(\"sysparm_name\", \"functionA\"); ga.addParam(\"a\", 9); // (This will print \"9\" as a warning to the browser's console) ga.getXMLAnswer(console.warn); } Members &lt;private&gt; generalOptions :Object General options to use with all $HTTP calls Type: Object Source: providers/spglideajax.js, line 68 &lt;private&gt; regexSpace :RegExp Static space reference for quick replacement. Type: RegExp Source: providers/spglideajax.js, line 38 Methods addParam(field, value) Sets a parameter for a pending AJAX request. Parameters: Name Type Description field String The name of the field to be passed. value String The value to be passed for that field. Source: providers/spglideajax.js, line 117 getAnswer(callback) Uses the parameters object to handle processing. If the sysparm_name property is missing, a warning is sent to the console for developer awareness. Parameters: Name Type Description callback function Takes callback(answer, error) and resolves appropriately the same as the returned promise. Source: providers/spglideajax.js, line 82 Returns: The promise resolves with the answer XML element on success or an Error object on failure. Type Promise getXMLAnswer(callback) Get the answer property from the returned XML. Parameters: Name Type Description callback function Takes callback(answer, error) and resolves appropriately the same as the returned promise. Source: providers/spglideajax.js, line 127 Returns: Resolves on success with the answer string and on failure throws to the catch chain. Type Promise serializeToForm(data) Service-Now's GlideAjax works with form data strings instead of JSON, so this is used to convert the parameters to the appropriate format. Parameters: Name Type Description data Object The object to parse into form data. The values off the object should be easily represented as strings or issues may occur. Source: providers/spglideajax.js, line 40 Returns: Form data string of the data in the passed object Type String × Search results Close "},"module-ScriptIncludes.html":{"id":"module-ScriptIncludes.html","title":"Module: ScriptIncludes","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Module: ScriptIncludes Source: scripts/include.js, line 1 Classes ActionTableScriptAPI × Search results Close "},"module-ScriptIncludes.ActionTableScriptAPI.html":{"id":"module-ScriptIncludes.ActionTableScriptAPI.html","title":"Class: ActionTableScriptAPI","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Class: ActionTableScriptAPI ScriptIncludes. ActionTableScriptAPI new ActionTableScriptAPI() Contains assistive methods for working with the ActionTable widget and acts as an anchor point for leveraging server-side data with script includes while not using the SPGlideAJAX functionality. Note that ActionTable supports pulling data from a client callable script include as well as leveraging the REST API (Though authentication may pose issues with REST). Extending this class instead of AbstractAjaxProcessor is not necessary from a functionality perspective, but does help to track or imply why that script exists. Source: scripts/include.js, line 3 Methods finishQuery(queried) Takes a general query and flushes out the record data with field descriptors. Parameters: Name Type Description queried GlideRecord That has the search parameters entered and query() has been called. Source: scripts/include.js, line 23 Returns: With Type Array generateExampleData(filter, page_size) Returns non-persistent random data; If a page is requested twice, the data will not be the same. Uses page_size to gauge the amount of data to generate. Parameters: Name Type Description filter String page_size Number Defaults to 30 Source: scripts/include.js, line 142 Returns: Length either 5 * page_size or 30 of semi-random. Type Array getExampleData(filter, page_size) Returns non-persistent random data; If a page is requested twice, the data will not be the same. Uses page_size to gauge the amount of data to generate. Parameters: Name Type Description filter String page_size Number Defaults to 30 Source: scripts/include.js, line 174 Returns: Length either 5 * page_size or 30 of semi-random. Type Array getFieldDescription(record, name) Retrieve the value for the field along with additional descriptive information about the field in an object to add to the row data. This does create somewhat of a duplication of data as this extra data will be the same across several rows. Parameters: Name Type Description record GlideRecord name String Source: scripts/include.js, line 54 Returns: With properties; display_value, value, type, label Type Object getTableData(table, query [, page_size] [, page]) Pull general data from a table. Parameters: Name Type Argument Description table String To query query String Encoded Query to pass into the query. page_size Number &lt;optional&gt; Optional limiter for number of rows to retrieve. page Number &lt;optional&gt; Optional offset for getting a specific page of data. Source: scripts/include.js, line 113 Returns: Of records. Type Array toJSON(record) Convert a GlideRecord's data to JSON. This method does NOT use getFieldDescription as that isn't the expected mode for the ActionTable widget. If looking for more flushed out data, use the finishQuery method instead. Parameters: Name Type Description record GlideRecord Source: scripts/include.js, line 82 Returns: Type Object × Search results Close "},"module-Specifications.html":{"id":"module-Specifications.html","title":"Module: Specifications","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Module: Specifications Collection of classes that merely describe data used in the Widget. Source: widget/specifications.js, line 1 × Search results Close "},"module-WidgetComponents.html":{"id":"module-WidgetComponents.html","title":"Module: WidgetComponents","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Module: WidgetComponents Source: widget/server.js, line 1 Classes ActionTableController ActionTableServerScript × Search results Close "},"module-WidgetComponents.ActionTableServerScript.html":{"id":"module-WidgetComponents.ActionTableServerScript.html","title":"Class: ActionTableServerScript","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Class: ActionTableServerScript WidgetComponents. ActionTableServerScript new ActionTableServerScript() The Angular controller for managing the Action Table Source: widget/server.js, line 2 Type Definitions data Object created by Service-Now and passed to the Widget controller on initialization. Type: Object Properties: Name Type Description loaded Number Timestamp for when the data was retrieved rows Array Contains the row data for the table error String Message from an error while building the data for the table Source: widget/server.js, line 7 options Object created by Service-Now and passed to the Widget controller on initialization. Type: Object Properties: Name Type Description filterable String Comma seperated list of fields that should be added to the $search property of objects for easy filtering. per_page Number Forces the table to show a set number of rows per page of data and hides the per_page selector on the table. refresh_interval Number Milliseconds to wait between pulling data from the server again. data_source String Indicating where/how to retrieve data. Source: widget/server.js, line 16 × Search results Close "},"Specifications.Action.html":{"id":"Specifications.Action.html","title":"Class: Action","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Class: Action Action Describes options to present to the user on the table to take an action on a specific row. This exists only for documentation purposes and is not actually defined in the instance. new Action() Source: widget/action.js, line 9 Members action :String Indicating how interactions with this action should process. Specific actions that are available: link or newlink go to a URL. newlink doing so in a new window or tab form-modal opens a modal on the page with a form view. Every key's value is filled in for the object passed to the modal. This action also uses several specific extra key values; table, sys_id, and view to specify the form to open. These values are template completed before being invoked. ajax-call makes an AJAX call similar to a GlideAjax call. This action also fills out the key values for all keys on the object and then passes each key as a parameter in the AJAX call. The tbl_class is used to initialize the SPGlideAjax instance and tbl_method is specifically added as the \"sysparm_name\" parameter of the AJAX call. Both keys can also be specified specifically as a key:value pair on the row's data that can be completed for a more dynamic AJAX call. Additionally, a tbl_complete key is used for a switch case that can be either redirect or newwindow and will use the new_url key to open or redirect once a response is received. However, as a note, deeply nested data will NOT get replacements. Type: String Source: widget/action.js, line 46 ajax_class :String Only for the ajax-call action. Specifies the class on which to initialize the GlideAjax. Type: String Source: widget/action.js, line 77 ajax_complete :String Only for the ajax-call action. Optional specification of an action to take once the call is complete. Possible values: redirect newwindow Type: String Source: widget/action.js, line 92 ajax_method :String Only for the ajax-call action. Specifies the method to invoke on the Script Include. Type: String Source: widget/action.js, line 82 condition :Object Optional object describing values that have to match for the action to display Type: Object Source: widget/action.js, line 51 icon :String With classes specifically for rendering an icon. This will generally follow font-awesome 4.7 or another glyph set included on your portal Type: String Source: widget/action.js, line 15 label :String For the displayed text Type: String Source: widget/action.js, line 20 perform :String Only for the link or newlink action, this specifies the URL. Template tokens here are replaced by the data rows' values. Type: String Source: widget/action.js, line 57 sys_id :String Only for the form-modal action. Specifies the sys_id of the record to open in the form. Type: String Source: widget/action.js, line 67 table :String Only for the form-modal action. Specifies the table against which the form should open. Type: String Source: widget/action.js, line 62 title :String Used for hover text (HTML title property) on the button Type: String Source: widget/action.js, line 25 view :String Only for the form-modal action. Specifies the view to use for the record in the modal. Type: String Source: widget/action.js, line 72 × Search results Close "},"Specifications.Column.html":{"id":"Specifications.Column.html","title":"Class: Column","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Class: Column Column Describes a field from a row data object to render on the table. This exists only for documentation purposes and is not actually defined in the instance. new Column() Source: widget/column.js, line 8 Members field :String To pull the data from on the row data object. Type: String Source: widget/column.js, line 20 label :String Displayed essentially as the header for this column on the table. Type: String Source: widget/column.js, line 15 × Search results Close "},"Specifications.State.html":{"id":"Specifications.State.html","title":"Class: State","body":" ActionTable Modules AngularProvidersScriptIncludesSpecificationsWidgetComponents Classes AngularProviders.SPGlideAjaxScriptIncludes.ActionTableScriptAPIWidgetComponents.ActionTableControllerWidgetComponents.ActionTableServerScriptSpecifications.ActionSpecifications.ColumnSpecifications.State Class: State State Important stateful data for the Widget. This exists only for documentation purposes and is not actually defined in the instance. new State() Source: widget/state.js, line 8 Members above :Number Controls the sort ordering and is returned when a is considered to precede b. Type: Number Source: widget/state.js, line 45 below :Number Controls the sort ordering and is returned when a is considered to procede b. Type: Number Source: widget/state.js, line 51 order :Number Names the column by which to sort rows using the field value of the column. If the field does not exist, no ordering is explicitly performed Type: Number Source: widget/state.js, line 39 page :Number The current page of the table being rendered. Type: Number Source: widget/state.js, line 20 search :String Used for filtering a row based on the values within it. Type: String Source: widget/state.js, line 15 size :Number The number of rows to display per page. of the state.size value is copied here used for user control of the paging size. This is later in a $watch statement to handle keeping size straight when changed this way. Direct modifications to state.size after the widget has been created will NOT currently be reflected back to this value. Type: Number Source: widget/state.js, line 31 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
