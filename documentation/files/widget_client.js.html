<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>widget\client.js - action-table</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="action-table" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ActionTableController.html">ActionTableController</a></li>
                                <li><a href="../classes/ActionTableScriptAPI.html">ActionTableScriptAPI</a></li>
                                <li><a href="../classes/SPGlideAjax.html">SPGlideAjax</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/AngularProviders.html">AngularProviders</a></li>
                                <li><a href="../modules/Service.html">Service</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: widget\client.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
api.controller = function($scope, $http, spModal, SPGlideAjax) {
	/**
	 * The Angular controller for managing the Action Table
	 * @class ActionTableController
	 * @constructor
	 */
	/**
	 * Identitifies the localStorage key used for saving and recovering the current state
	 * of the table&#x27;s rendering.
	 * @property stateKey
	 * @type String
	 * @private
	 */
	/**
	 * Time to wait to allow typing to continue before updating the corpus.
	 * @property filterInterval
	 * @default 200
	 * @type Number
	 * @private
	 */
	var stateKey = &quot;actiontable:state:&quot; + $scope.options.id,
		loading = localStorage.getItem(stateKey),
		filterInterval = 200,
		fieldTracking = {},
		fieldList = [],
		mapDataFields,
		clearFault,
		endReload,
		filtering,
		mapFields,
		saveState,
		sortData,
		setIcons,
		refresh,
		visible,
		timing,
		fillin,
		fault,
		x;

	/**
	 * Save an encoded value of the scope&#x27;s state value to give persistence to the table&#x27;s
	 * rendering.
	 * @method saveState
	 * @private
	 */
	saveState = function() {
		localStorage.setItem(stateKey, JSON.stringify($scope.state));
	};
	/**
	 * Updates the icons for various objects for cached rendering purposes
	 * @method setIcons
	 */
	setIcons = function() {
		if($scope.columns) {
			var column;
			for(x=0; x&lt;$scope.columns.length; x++) {
				column = $scope.columns[x];
				if(column &amp;&amp; !column.no_sort) {
					if(column.field === $scope.state.order) {
						if($scope.state.above === 1) {
							column.sort_icon = &quot;fa fa-sort-alpha-asc&quot;;
						} else {
							column.sort_icon = &quot;fa fa-sort-alpha-desc&quot;;
						}
					} else {
						column.sort_icon = &quot;fa fa-sort&quot;;
					}
				}
			}
		}
	};
	/**
	 * Sorting function used to sort the data.rows array based on the current state values.
	 * @method sortData
	 * @param a
	 * @param b
	 */
	sortData = function(a, b) {
		if($scope.state.order) {
			if(a &amp;&amp; b) {
				var cA = a[$scope.state.order],
					cB = b[$scope.state.order];
				if(cA &gt; cB) {
					return $scope.state.above;
				} else if(cA &lt; cB) {
					return $scope.state.below;
				}
			} else if(a &amp;&amp; !b) {
				return $scope.state.above;
			} else if(!a &amp;&amp; b) {
				return $scope.state.below;
			}
			return 0;
		}
	};
	/**
	 * 
	 * @method visible
	 * @param {Object} row
	 */
	visible = function(row) {
		return !$scope.state.searching || (row &amp;&amp; typeof(row.$search) === &quot;string&quot; &amp;&amp; row.$search.indexOf($scope.state.searching) !== -1);
	};
	/**
	 * Timed function used to balance user typing with when to fire updating the results.
	 * @method filtering
	 * @private
	 */
	filtering = function() {
		var now = Date.now();
		if(timing &amp;&amp; timing &lt; now) {
			// Maintain case insensitive search but don&#x27;t mutate the user input
			$scope.state.searching = $scope.state.search.toLowerCase();
			$scope.state.page = 0;
			$scope.filterIcon = &quot;fa-filter&quot;;
			$scope.loadCorpus();
			$scope.update();
			timing = null;
			saveState();
		} else {
			setTimeout(filtering, filterInterval);
		}
	};
	/**
	 * Used to keep the data up to date if a refresh interval has been specified.
	 * @method refresh
	 * @private
	 */
	refresh = function() {
		if(!isNaN($scope.options.refresh_interval) &amp;&amp; 60000 &lt;= $scope.options.refresh_interval) {
			$scope.reloadData();
			setTimeout(refresh, $scope.options.refresh_interval);
		}
	};
	/**
	 * Waits 1 second to reset the reload icon to give the visual impact time.
	 * @method endReload
	 * @private
	 */
	endReload = function() {
		setTimeout(function() {
			$scope.reload_icon = &quot;fa-refresh&quot;;
			$scope.update();
		}, 1000);
	};
	/**
	 * Use template filling to create a new object whose values mimic the fill object but
	 * with templates completed based on the row. Due to the regular expressions in volved
	 * and the number of search/replacements that can be triggered here, this method should
	 * be used sparingly.
	 * @method fillin
	 * @param {Object} fill Object whose values are to be completed
	 * @param {Object} row Source for values
	 */
	fillin = function(fill, row) {
		var keys = Object.keys(fill),
			result = {},
			i;
		for(i=0; i&lt;keys.length; i++) {
			result[keys[i]] = $scope.completeTemplate(row, fill[keys[i]]);
		}
		return result;
	};
	/**
	 * Internal method for displaying an error that was encountered.
	 * @method fault
	 * @private
	 * @param {Error} error That occurred and should be displayed
	 */
	fault = function(error) {
		var message = &quot;STSTable: Data Request from &quot;;
		if($scope.options.data_source == &quot;ajax&quot;) {
			message += &quot;Client Script[&quot; + $scope.options.script + &quot;.&quot; + $scope.options.script_method + &quot;]: &quot;;
		} else if($scope.options.data_source == &quot;snapi&quot;) {
			message += &quot;Service-Now API Endpoint[&quot; + $scope.options.endpoint + &quot;]: &quot;;
		} else {
			&quot;Unknown Source: &quot;;
		}
		console.error(message, $scope.error);
		$scope.error = error;
		$scope.update();
	};
	/**
	 * Internal method for clearing an error that had been encountered if one such error exists.
	 * @method clearFault
	 * @private
	 */
	clearFault = function() {
		if($scope.error) {
			$scope.error = null;
			$scope.update();
		}
	};
	/**
	 * Updates the fieldTracking &amp; fieldList properties.
	 * @method mapDataFields
	 */
	mapDataFields = function() {
		var i;

		fieldList.splice(0);
		if($scope.data.rows &amp;&amp; $scope.data.rows.length) {
			for(i=0; i&lt;$scope.data.rows.length; i++) {
				mapFields($scope.data.rows[i]);
			}
		}

		fieldList.push.apply(fieldList, Object.keys(fieldTracking));
	};
	/**
	 * Checks the object keys to ensure that all fields have a RegExp mapping in the &#x60;fieldTracking&#x60;
	 * object.
	 * @method mapFields
	 * @param {Object} row
	 */
	mapFields = function(row) {
		var keys = Object.keys(row),
			i;
		for(i=0; i&lt;keys.length; i++) {
			if(!fieldTracking[keys[i]]) {
				fieldTracking[keys[i]] = new RegExp(&quot;\\{\\{&quot; + keys[i] + &quot;\\}\\}&quot;, &quot;ig&quot;);
			}
		}
	};

	// Initialize local data for table management
	try {
		$scope.columns = JSON.parse($scope.options.columns);
	} catch(parseException) {
		console.error(&quot;Action Table: Failed to parse column specifications:&quot;, parseException, $scope.options.columns);
		$scope.error = parseException;
	}
	try {
		$scope.actions = JSON.parse($scope.options.actions);
	} catch(parseException) {
		console.error(&quot;Action Table: Failed to parse action specifications:&quot;, parseException, $scope.options.actions);
		$scope.error = parseException;
	}

	/**
	 * Handles displaying an error to the widget.
	 * 
	 * Generally set by calling the private function &#x60;fault&#x60;.
	 * @property error
	 * @type Error
	 */
	if($scope.data.error) {
		$scope.error = new Error($scope.data.error);
	}
	/**
	 * 
	 * The displayed icon in the filter to give feedback to the user.
	 * @property filterIcon
	 * @type String
	 */
	$scope.filterIcon = &quot;fa-filter&quot;;
	/**
	 * The displayed icon for reloading data to give feedback to the user.
	 * @property filterIcon
	 * @type String
	 */
	$scope.reload_icon = &quot;fa-refresh&quot;;
	/**
	 * Each element contained here is an element that is valid after the rows have been
	 * filtered by search and sort criteria.
	 * @property corpus
	 * @type Array
	 */
	$scope.corpus = [];
	/**
	 * Each element contained here is a row to render on the page. This is pared down to
	 * only the rows that should render based on the current page and sourced from the
	 * corpus array to follow search and sort criteria and drive a faster rendering.
	 * @property render
	 * @type Array
	 */
	$scope.render = [];
	/**
	 * Doubles as a page count and rendering array for ng-repeat.
	 * @property pages
	 * @type Array
	 */
	$scope.pages = [];

	// Attempt to recover the previous state of the table, if any
	/**
	 * 
	 * @property state
	 * @type Object
	 */
	if(loading) {
		try {
			$scope.state = JSON.parse(loading);
		} catch(loadException) {
			console.error(&quot;ActionTable: State Loading Error: &quot;, loadException);
			$scope.state = {};
		}
	} else {
		$scope.state = {};
	}
	/**
	 * 
	 * @property state.page
	 * @type Number
	 */
	if($scope.state.page === undefined) {
		$scope.state.page = 0;
	}
	/**
	 * Used for filtering a row based on the values within it.
	 * @property state.search
	 * @type String
	 */
	if($scope.state.search === undefined) {
		$scope.state.search = &quot;&quot;;
	}
	/**
	 * The number of rows to display per page.
	 * @property state.size
	 * @type Number
	 */
	if(!isNaN($scope.options.per_page) &amp;&amp; $scope.options.per_page &gt; 0) {
		$scope.state.size = $scope.options.per_page;
	} else if(isNaN($scope.state.size)) {
		$scope.state.size = 20;
	}
	/**
	 * As &quot;select&quot; elements match on strings, a string version of the &#x60;state.size&#x60;
	 * value is copied here used for user control of the paging size. This is later
	 * in a $watch statement to handle keeping size straight when changed this way.
	 * 
	 * Direct modifications to &#x60;state.size&#x60; after the widget has been created will
	 * NOT currently be reflected back to this value.
	 * @property state.per_page
	 * @type String
	 */
	$scope.state.per_page = $scope.state.size.toString();
	/**
	 * Names the column by which to sort rows using the field value of the column.
	 * 
	 * If the field does not exist, no ordering is explicitly performed.
	 * @property state.order
	 * @type String
	 * @defaul null
	 */
	/**
	 * Controls the sort ordering and is returned when &#x60;a&#x60; is considered to precede &#x60;b&#x60;.
	 * @property state.above
	 * @type Number
	 * @default -1
	 */
	if($scope.state.above === undefined) {
		$scope.state.above = -1;
	}
	/**
	 * Controls the sort ordering and is returned when &#x60;a&#x60; is considered to procede &#x60;b&#x60;.
	 * @property state.below
	 * @type Number
	 * @default 1
	 */
	if($scope.state.below === undefined) {
		$scope.state.below = -1 * $scope.state.above;
	}

	// Cache regular expressions for quick template replacements based on the row&#x27;s field values
	mapDataFields();

	// When the search string changes, trigger the filtering function to eventually update the rendered values
	$scope.$watch(&quot;state.search&quot;, function() {
		if(!timing) {
			$scope.filterIcon = &quot;fa-spinner fa-pulse&quot;;
			$scope.update();
			filtering();
		}
		timing = Date.now() + 2 * filterInterval;
	});

	// Watch for changes to the size string, likely by the corner select, to push the value into the state and update
	$scope.$watch(&quot;state.per_page&quot;, function() {
		$scope.state.size = parseInt($scope.state.per_page);
		$scope.loadCorpus();
		saveState();
	});

	/**
	 * Change the direction of sorting or the column to sort by.
	 * 
	 * Calling on the currently sorted column toggles the sort direction.
	 * 
	 * Changing to a new column does NOT change the sort direction.
	 * @method reorder
	 * @param {Object} column 
	 */
	$scope.reorder = function(column) {
		if(column) {
			if($scope.state.order === column.field) {
				$scope.state.below *= -1;
				$scope.state.above *= -1;
			} else {
				$scope.state.order = column.field;
			}
			$scope.loadCorpus();
			saveState();
			setIcons();
		}
	};

	/**
	 * Retrieves data from the server if necessary.
	 * 
	 * This is essesntially a stepping method for AJAX sourced data as the other 2 sources
	 * (server script, and table) would already be populated here by the server initialization.
	 * 
	 * The SPGlideAjax is heavily favored for the ability to create new configurable data sources
	 * without modifying the widget or its supporting pieces while also keeping the creating of
	 * the data in a more traditionally understood form, Script Includes, instead of passing the
	 * data through a more web traditional method such as an API, where Scripted APIs may get
	 * heavier. Though support for such a process should be added and would also be handled here.
	 * @method loadData
	 */
	$scope.loadData = function() {
		var request;
		
		clearFault();
		switch($scope.options.data_source) {
			case &quot;ajax&quot;:
				request = new SPGlideAjax($scope.options.script);
				request.addParam(&quot;sysparm_name&quot;, $scope.options.script_method);
				request.addParam(&quot;query&quot;, $scope.options.query);
				request.getXMLAnswer($scope.receiveData);
				break;
			case &quot;snapi&quot;:
				if($scope.options.endpoint) {
					if($scope.options.endpoint[0] !== &quot;/&quot;) {
						$scope.options.endpoint = &quot;/&quot; + $scope.options.endpoint;
					}
					$http.get($scope.options.endpoint + &quot;?query=&quot; + $scope.options.query)
					.then(function(response) {
						if(response.status === 200) {
							$scope.receiveData(response.data.result);
						} else {
							fault(new Error(&quot;Malformed request for endpoint data - HTTP&quot; + response.status + &quot;: &quot; + response.statusText));
						}
					}, fault);
				} else {
					fault(new Error(&quot;No &#x27;endpoint&#x27; option is defined&quot;));
				}
				break;
			case &quot;server&quot;:
			case &quot;table&quot;:
				$scope.prepareData();
				break;
			default:
				console.error(&quot;Unknown Data Source (data_source) option specified for STSTable widget[&quot; + $scope.options.id + &quot;]: &quot;, $scope);
				$scope.error = {
					&quot;message&quot;: &quot;Unknown Data Source (data_source) option specified for widget.&quot;,
					&quot;options&quot;: $scope.options
				};
		}
	};

	/**
	 * Called for receiving the text portion of a request for data. All text is assumed to be a JSON
	 * object with the general format:
	 * &#x60;&#x60;&#x60;
	 * {
	 *     &quot;rows&quot;: [{
	 *         Object 1 Data...
	 *     }, {
	 *         Object 2 Data...
	 *     }, {
	 *         ...
	 *     {, 
	 *         Object N Data...
	 *     }]
	 * }
	 * &#x60;&#x60;&#x60;
	 * 
	 * An object is used to allow for other information to be present on the API call for use later.
	 * @method receiveData
	 * @param {String} response 
	 */
	$scope.receiveData = function(response) {
		var loading;
		if(response) {
			if(typeof(response) === &quot;string&quot;) {
				try {
					loading = JSON.parse(response);
				} catch(parseException) {
					fault(parseException);
				}
			} else {
				loading = response;
			}
			if(loading &amp;&amp; loading.rows instanceof Array) {
				$scope.data.rows.splice(0);
				$scope.data.rows.push.apply($scope.data.rows, loading.rows);
				$scope.data.loaded = Date.now();
				$scope.prepareData();
			} else {
				fault(new Error(&quot;Receive malformed data, must return a Object JSON with a \&quot;rows\&quot; property that contains the array to load&quot;));
			}
		} else {
			fault(new Error(&quot;Failed to receive any data&quot;));
		}
	};


	/**
	 * Essentially prepares the data received from the server.
	 * 
	 * This primarily involves setting the &#x60;$search&#x60; property for easy lower cased
	 * string index checks for filtering based on the columns and &#x60;options.filterable&#x60;.
	 * 
	 * Additionally, the data objectis emitted on the root scope for other widgets to
	 * consume if needed under the event &quot;ststable:data:[ID]&quot; where &quot;[ID]&quot; is the table&#x27;s
	 * ID specified in options. This allows another widget on the same page as the table
	 * to implement something akin to &#x60;$scope.$on(&quot;ststable:data:[ID]&quot;, $scope.processAPIData)&#x60;
	 * to receive the data and perform any needed actions.
	 * @method loadData
	 */
	$scope.prepareData = function() {
		var column,
			load,
			row,
			c,
			i;

		if($scope.data.rows) {
			for(i=0; i&lt;$scope.data.rows.length; i++) {
				row = $scope.data.rows[i];
				row.$search = &quot;&quot;;
				// Ensure that the visible columns are searchable
				if($scope.options.filterable &amp;&amp; $scope.options.filterable.length) {
					// Add additional columns that are flagged as filterable in the instance options
					load = $scope.columns.concat($scope.options.filterable);
				} else {
					load = $scope.columns;
				}
				for(c=0; c&lt;load.length; c++) {
					column = load[c];
					if(typeof(row[column.field]) === &quot;string&quot;) {
						// Map to lower case; Filter is meant to be case insensitive
						row.$search += &quot; :: &quot; + row[column.field].toLowerCase();
					} else 
					if(typeof(row[column.field]) === &quot;object&quot;) {
						// Handle Field Descriptor data
						if(row[column.field].display) {
							row.$search += &quot; :: &quot; + row[column.field].display.toLowerCase();
						}
					} else {
						// Direct Value
						row.$search += &quot; :: &quot; + row[column.field];
					}
				}
			}
			$scope.corpus.sort(sortData);
		}

		mapDataFields();
		$scope.$root.$emit(&quot;ststable:data:&quot; + $scope.options.id, $scope.data);
		$scope.loadCorpus();
	};

	/**
	 * Filter and sort the general data received from the server.
	 * 
	 * This serves as our cache for paging through the data set.
	 * @method loadCorpus
	 */
	$scope.loadCorpus = function() {
		$scope.corpus.splice(0);
		$scope.pages.splice(0);
		var row,
			i;

		if($scope.data.rows) {
			for(i=0; i&lt;$scope.data.rows.length; i++) {
				row = $scope.data.rows[i];
				if(visible(row)) {
					$scope.corpus.push(row);
				}
			}
			$scope.corpus.sort(sortData);
		}

		$scope.page_count = $scope.corpus.length/$scope.state.size;
		for(i=0; i&lt;$scope.page_count; i++) {
			$scope.pages.push(i + 1);
		}

		$scope.loadRender();
	};

	/**
	 * Load data from the &#x60;corpus&#x60; to the &#x60;render&#x60; array for the current page being viewed.
	 * @method loadRender
	 */
	$scope.loadRender = function() {
		$scope.render.splice(0);

		var start = $scope.state.page * $scope.state.size,
			end = start + $scope.state.size,
			row,
			i;

		for(i=start; i&lt;end &amp;&amp; i&lt;$scope.corpus.length; i++) {
			row = $scope.corpus[i];
			if(row) {
				$scope.render.push(row);
			}
		}

		$scope.update();
	};

	/**
	 * Sets the page and updates the &#x60;render&#x60; array for display via the &#x60;loadRender&#x60; method.
	 * @method toPage
	 * @param {Number} page 
	 */
	$scope.toPage = function(page) {
		$scope.state.page = page - 1;
		$scope.loadRender();
		saveState();
	};

	/**
	 * 
	 * @method getPageClasses
	 * @param {Number} page 
	 * @returns {String}
	 */
	$scope.getPageClasses = function(page) {
		if(page -1 === $scope.state.page) {
			return &quot;btn-primary&quot;;
		} else {
			return &quot;btn-default&quot;;
		}
	};

	/**
	 * Check if an action is visible based on its &#x60;condition&#x60; object.
	 * 
	 * No condition object indicates it is always visible.
	 * 
	 * Condition checking is managed with the &#x60;checkConditions&#x60; function.
	 * @method actionVisible
	 * @param {Object} row 
	 * @param {Object} action 
	 * @return {Boolean}
	 */
	$scope.actionVisible = function(row, action) {
		if(action.condition) {
			return $scope.checkCondition(row, action.condition);
		}
		return true;
	};

	/**
	 * Process an action object for a row.
	 * @method processAction
	 * @param {Object} row 
	 * @param {Object} action 
	 */
	$scope.processAction = function(row, process) {
		var buffer,
			keys,
			i;

		switch(process.action) {
			case &quot;link&quot;:
				buffer = $scope.completeTemplate(row, process.perform);
				if(buffer[0] !== &quot;/&quot;) {
					buffer = &quot;/&quot; + buffer;
				}
				location = buffer;
				break;
			case &quot;newlink&quot;:
				buffer = $scope.completeTemplate(row, process.perform);
				if(buffer[0] !== &quot;/&quot;) {
					buffer = &quot;/&quot; + buffer;
				}
				window.open(buffer, &quot;_blank&quot;);
				break;
			case &quot;form-modal&quot;:
				process = fillin(process, row);
				console.log(&quot;FilledIn: &quot;, process);
				spModal.open({
					&quot;shared&quot;: $scope.state,
					&quot;value&quot;: process,
					&quot;title&quot;: process.title,
					&quot;widget&quot;: &quot;widget-form&quot;,
					&quot;widgetInput&quot;: process
				}).then(function (/* button */) {
					// User clicked &quot;OK&quot; - example; button = {&quot;label&quot;:&quot;OK&quot;,&quot;primary&quot;:true,&quot;focus&quot;:true}
				}, function(/* error */) {
					// User clicked &quot;Cancel&quot;, The close button on the dialog, or clicked outside the box
				});
				break;
			case &quot;ajax-call&quot;:
				process = fillin(process, row);
				keys = Object.keys(process);
				buffer = new SPGlideAjax(process.tbl_class);
				buffer.addParam(&quot;sysparm_name&quot;, process.tbl_method);
				for(i=0; i&lt;keys.length; i++) {
					buffer.addParam(keys[i], process[keys[i]]);
				}
				buffer.getXMLAnswer(function(/* response */) {
					if(process.new_url &amp;&amp; process.new_url[0] !== &quot;/&quot;) {
						process.new_url = &quot;/&quot; + process.new_url;
					}
					switch(process.tbl_complete) {
						case &quot;redirect&quot;:
							location = process.new_url;
							break;
						case &quot;newwindow&quot;:
							window.open(process.new_url, &quot;_blank&quot;);
							break;
					}
				});
				break;
		}
	};

	/**
	 * Get the string to display for the value in row under the column&#x27;s field value.
	 * @method renderValue
	 * @param {Object} row Of data from which to get the value to render.
	 * @param {Object} column Describing what data should be rendered.
	 * @return {String} To place in the table
	 */
	$scope.renderValue = function(row, column) {
		var point = row[column.field],
			formatting,
			buffer,
			value;

		buffer = typeof(point);
		if(buffer === &quot;object&quot;) {
			formatting = point.type || column.formatting || buffer;
			value = point.display;
		} else {
			formatting = column.formatting || buffer;
			value = point;
		}

		switch(formatting) {
			case &quot;time&quot;:
				buffer = new Date(value);
				return buffer.toLocaleDateString() + &quot; &quot; + buffer.toLocaleTimeString();
			case &quot;date&quot;:
				buffer = new Date(value);
				return buffer.toLocaleDateString();
		}
		// Contain runaway decimal point values
		if(typeof(value) === &quot;number&quot; &amp;&amp; value%1) {
			value = value.toFixed(3);
		}
		return value;
	};

	/**
	 * Using a Modal, show the status text for the row.
	 * @method viewStatusWarning
	 * @param {Object} row 
	 */
	$scope.viewStatusWarning = function(row) {
		spModal.confirm(row.$status_text);
	};

	/**
	 * Performs basic token replacement in a string based on the values in the row object using &quot;{{...}}&quot; for replacement
	 * indicators.
	 * 
	 * Due to service-now template processing, using &quot;${...}&quot; fails without oerly complicated syntax, for example
	 * an option value of &quot;My name is ${name}&quot; simply displays as &quot;My name is name&quot; and looking at the option value
	 * received to the widget, the value of that option will also be &quot;My name is name&quot; because Sevice-Now&#x27;s templating
	 * has already altered the value.
	 * 
	 * Additionally note that the replacement handling is managed with cached regular expressions generated at the start
	 * of this controller.
	 * @method completeTemplate
	 * @param {Object} row 
	 * @param {String} template 
	 * @returns {String} 
	 */
	$scope.completeTemplate = function(row, template) {
		for(var i=0; i&lt;fieldList.length; i++) {
			template = template.replace(fieldTracking[fieldList[i]], row[fieldList[i]] || &quot;&quot;);
		}
		return template;
	};

	/**
	 * Every field in the condition that is defined must match the corresponding field value in the row, or the
	 * check fails.
	 * @method checkCondition
	 * @param {Object} row 
	 * @param {Object} condition
	 * @returns {Boolean} 
	 */
	$scope.checkCondition = function(row, condition) {
		for(var i=0; i&lt;fieldList.length; i++) {
			if(condition[fieldList[i]] !== undefined &amp;&amp; condition[fieldList[i]] !== row[fieldList[i]]) {
				return false;
			}
		}
		return true;
	};

	/**
	 * Get a new array of data from the server and apply it to the current state and render.
	 * @method reloadData
	 */
	$scope.reloadData = function() {
		var success,
			failure;

		if($scope.options.data_source == &quot;ajax&quot;) {
			$scope.loadData();
		} else {
			success = function(response) {
				$scope.data.rows.splice(0);
				$scope.data.rows.push.apply($scope.data.rows, response.data.rows);
				$scope.data.loaded = response.data.loaded;
				$scope.loadData();
				endReload();
			};
			failure = function(error) {
				$scope.error = error;
				endReload();
			};

			$scope.reload_icon = &quot;fa-refresh fa-spin&quot;;
			$scope.update();

			$scope.server.get()
			.then(success, failure);
		}
	};

	/**
	 * 
	 * @method getLastUpdateDisplay
	 * @returns {String} 0
	 */
	$scope.getLastUpdateDisplay = function() {
		var date = new Date($scope.data.loaded);
		return date.toLocaleDateString() + &quot; &quot; + date.toLocaleTimeString();
	};

	/**
	 * Forces a re-rendering of AngularJS bindings
	 * @method update
	 */
	$scope.update = function() {
		try {
			$scope.$digest();
		} catch(updateException) {
			// Generally just a digest exception from a current update cycle
		}
	};

	// Initialize Corpus for rendering based on the loaded state
	if(!isNaN($scope.options.refresh_interval) &amp;&amp; $scope.options.refresh_interval) {
		setTimeout(refresh, $scope.options.refresh_interval);
	}
	$scope.loadData();
	setIcons();
};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
